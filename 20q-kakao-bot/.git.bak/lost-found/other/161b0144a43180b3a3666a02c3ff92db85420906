package party.qwer.twentyq.redis.queue

import com.fasterxml.jackson.databind.ObjectMapper
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.redisson.api.RBlockingQueue
import org.redisson.api.RedissonClient
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import party.qwer.twentyq.model.PendingMessage
import party.qwer.twentyq.redis.RedisKeys
import java.time.Duration

// Redisson RBlockingQueue 기반 대기 메시지 저장소
@Component
class PendingMessageStore(
    private val redissonClient: RedissonClient,
    private val objectMapper: ObjectMapper,
) {
    companion object {
        private val log = LoggerFactory.getLogger(PendingMessageStore::class.java)
        private const val QUEUE_TTL_SECONDS = 3600L // 1시간
        private const val MAX_QUEUE_SIZE = 100 // DoS 방지
        private const val STALE_MESSAGE_THRESHOLD_MS = 3600_000L // 1시간
    }

    suspend fun enqueue(
        chatId: String,
        message: PendingMessage,
    ): Boolean =
        withContext(Dispatchers.IO) {
            val queue = getQueue(chatId)
            if (queue.size >= MAX_QUEUE_SIZE) {
                log.warn("QUEUE_OVERFLOW chatId={}, size={}", chatId, queue.size)
                return@withContext false
            }

            val json = objectMapper.writeValueAsString(message)
            queue.offer(json)
            queue.expire(Duration.ofSeconds(QUEUE_TTL_SECONDS))
            log.debug("MESSAGE_ENQUEUED chatId={}, userId={}, size={}", chatId, message.userId, queue.size)
            true
        }

    @Suppress("LoopWithTooManyJumpStatements")
    suspend fun dequeueAll(chatId: String): List<PendingMessage> =
        withContext(Dispatchers.IO) {
            val queue = getQueue(chatId)
            val messages = mutableListOf<PendingMessage>()
            val now = System.currentTimeMillis()

            while (queue.isNotEmpty()) {
                val json = queue.poll() ?: break
                val message = objectMapper.readValue(json, PendingMessage::class.java)

                // Stale 메시지 필터링
                if (now - message.timestamp > STALE_MESSAGE_THRESHOLD_MS) {
                    log.warn(
                        "STALE_MESSAGE_FILTERED chatId={}, userId={}, age={}ms",
                        chatId,
                        message.userId,
                        now - message.timestamp,
                    )
                    continue
                }

                messages.add(message)
            }

            if (messages.isNotEmpty()) {
                log.debug("MESSAGES_DEQUEUED chatId={}, count={}", chatId, messages.size)
            }
            messages
        }

    suspend fun peek(chatId: String): PendingMessage? =
        withContext(Dispatchers.IO) {
            val queue = getQueue(chatId)
            val json = queue.peek() ?: return@withContext null
            objectMapper.readValue(json, PendingMessage::class.java)
        }

    suspend fun size(chatId: String): Int =
        withContext(Dispatchers.IO) {
            getQueue(chatId).size
        }

    suspend fun clear(chatId: String) =
        withContext(Dispatchers.IO) {
            val queue = getQueue(chatId)
            val size = queue.size
            queue.clear()
            log.debug("QUEUE_CLEARED chatId={}, clearedCount={}", chatId, size)
        }

    private fun getQueue(chatId: String): RBlockingQueue<String> {
        val key = "${RedisKeys.PENDING_MESSAGES}:$chatId"
        return redissonClient.getBlockingQueue(key)
    }
}
