package party.qwer.twentyq.redis.tracking

import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import org.springframework.data.redis.core.ListOperations
import org.springframework.data.redis.core.SetOperations
import org.springframework.data.redis.core.StringRedisTemplate
import org.springframework.data.redis.core.ValueOperations
import party.qwer.twentyq.config.AppProperties
import java.time.Duration

@DisplayName("TrackingStores 테스트")
class TrackingStoresTest {
    private lateinit var redis: StringRedisTemplate
    private lateinit var props: AppProperties

    @BeforeEach
    fun setup() {
        redis = mockk(relaxed = true)
        props = mockk(relaxed = true)
        every { props.redis.sessionTtlMinutes } returns 30L
        every { props.riddle.game.recentTopicsLimit } returns 20
    }

    @Nested
    @DisplayName("HintCountStore")
    inner class HintCountStoreTest {
        private lateinit var valueOps: ValueOperations<String, String>
        private lateinit var store: HintCountStore

        @BeforeEach
        fun setup() {
            valueOps = mockk(relaxed = true)
            every { redis.opsForValue() } returns valueOps
            store = HintCountStore(redis, props)
        }

        @Test
        fun `get - 힌트 카운트 조회 성공`() {
            // given
            val roomId = "room123"
            every { valueOps.get("20q:hints:$roomId") } returns "3"

            // when
            val result = store.get(roomId)

            // then
            assertThat(result).isEqualTo(3)
            verify { valueOps.get("20q:hints:$roomId") }
        }

        @Test
        fun `get - 카운트 없음 시 0 반환`() {
            // given
            val roomId = "room123"
            every { valueOps.get("20q:hints:$roomId") } returns null

            // when
            val result = store.get(roomId)

            // then
            assertThat(result).isEqualTo(0)
        }

        @Test
        fun `increment - 카운트 증가 및 TTL 설정`() {
            // given
            val roomId = "room123"
            every { valueOps.increment("20q:hints:$roomId") } returns 1L

            // when
            val result = store.increment(roomId)

            // then
            assertThat(result).isEqualTo(1L)
            verify { valueOps.increment("20q:hints:$roomId") }
            verify { redis.expire("20q:hints:$roomId", Duration.ofMinutes(30L)) }
        }

        @Test
        fun `delete - 카운트 삭제`() {
            // given
            val roomId = "room123"

            // when
            store.delete(roomId)

            // then
            verify { redis.delete("20q:hints:$roomId") }
        }

        @Test
        fun `setTtl - TTL 갱신`() {
            // given
            val roomId = "room123"
            val ttl = Duration.ofMinutes(10)

            // when
            store.setTtl(roomId, ttl)

            // then
            verify { redis.expire("20q:hints:$roomId", ttl) }
        }
    }

    @Nested
    @DisplayName("PlayerSetStore")
    inner class PlayerSetStoreTest {
        private lateinit var setOps: SetOperations<String, String>
        private lateinit var store: PlayerSetStore

        @BeforeEach
        fun setup() {
            setOps = mockk(relaxed = true)
            every { redis.opsForSet() } returns setOps
            store = PlayerSetStore(redis, props)
        }

        @Test
        fun `add - 플레이어 추가 및 TTL 설정`() {
            // given
            val roomId = "room123"
            val userId = "user1"

            // when
            store.add(roomId, userId)

            // then
            verify { setOps.add("20q:players:$roomId", userId) }
            verify { redis.expire("20q:players:$roomId", Duration.ofMinutes(30L)) }
        }

        @Test
        fun `getAll - 모든 플레이어 조회`() {
            // given
            val roomId = "room123"
            val players = setOf("user1", "user2", "user3")
            every { setOps.members("20q:players:$roomId") } returns players

            // when
            val result = store.getAll(roomId)

            // then
            assertThat(result).containsExactlyInAnyOrder("user1", "user2", "user3")
            verify { setOps.members("20q:players:$roomId") }
        }

        @Test
        fun `getAll - 플레이어 없음 시 빈 Set 반환`() {
            // given
            val roomId = "room123"
            every { setOps.members("20q:players:$roomId") } returns null

            // when
            val result = store.getAll(roomId)

            // then
            assertThat(result).isEmpty()
        }

        @Test
        fun `clear - 모든 플레이어 삭제`() {
            // given
            val roomId = "room123"

            // when
            store.clear(roomId)

            // then
            verify { redis.delete("20q:players:$roomId") }
        }

        @Test
        fun `setTtl - TTL 갱신`() {
            // given
            val roomId = "room123"
            val ttl = Duration.ofMinutes(15)

            // when
            store.setTtl(roomId, ttl)

            // then
            verify { redis.expire("20q:players:$roomId", ttl) }
        }
    }

    @Nested
    @DisplayName("WrongGuessSetStore")
    inner class WrongGuessSetStoreTest {
        private lateinit var listOps: ListOperations<String, String>
        private lateinit var store: WrongGuessSetStore

        @BeforeEach
        fun setup() {
            listOps = mockk(relaxed = true)
            every { redis.opsForList() } returns listOps
            store = WrongGuessSetStore(redis, props)
        }

        @Test
        fun `add - 오답 추가 및 TTL 설정`() {
            // given
            val roomId = "room123"
            val guess = "호랑이"

            // when
            store.add(roomId, guess)

            // then
            verify { listOps.rightPush("20q:wrongGuesses:$roomId", guess) }
            verify { redis.expire("20q:wrongGuesses:$roomId", Duration.ofMinutes(30L)) }
        }

        @Test
        fun `getAll - 모든 오답 조회`() {
            // given
            val roomId = "room123"
            val guesses = listOf("호랑이", "코끼리", "사슴")
            every { listOps.range("20q:wrongGuesses:$roomId", 0, -1) } returns guesses

            // when
            val result = store.getAll(roomId)

            // then
            assertThat(result).containsExactly("호랑이", "코끼리", "사슴")
            verify { listOps.range("20q:wrongGuesses:$roomId", 0, -1) }
        }

        @Test
        fun `getAll - 오답 없음 시 빈 List 반환`() {
            // given
            val roomId = "room123"
            every { listOps.range("20q:wrongGuesses:$roomId", 0, -1) } returns null

            // when
            val result = store.getAll(roomId)

            // then
            assertThat(result).isEmpty()
        }

        @Test
        fun `delete - 오답 목록 삭제`() {
            // given
            val roomId = "room123"

            // when
            store.delete(roomId)

            // then
            verify { redis.delete("20q:wrongGuesses:$roomId") }
        }

        @Test
        fun `setTtl - TTL 갱신`() {
            // given
            val roomId = "room123"
            val ttl = Duration.ofMinutes(20)

            // when
            store.setTtl(roomId, ttl)

            // then
            verify { redis.expire("20q:wrongGuesses:$roomId", ttl) }
        }
    }

    @Nested
    @DisplayName("TopicHistoryStore")
    inner class TopicHistoryStoreTest {
        private lateinit var listOps: ListOperations<String, String>
        private lateinit var store: TopicHistoryStore

        @BeforeEach
        fun setup() {
            listOps = mockk(relaxed = true)
            every { redis.opsForList() } returns listOps
            store = TopicHistoryStore(redis, props)
        }

        @Test
        fun `getRecent - 최근 주제 조회 (카테고리 없음)`() {
            // given
            val roomId = "room123"
            val topics = listOf("사자", "김치", "에펠탑")
            every { listOps.range("20q:topics:$roomId", 0, 19) } returns topics

            // when
            val result = store.getRecent(roomId, 20)

            // then
            assertThat(result).containsExactly("사자", "김치", "에펠탑")
            verify { listOps.range("20q:topics:$roomId", 0, 19) }
        }

        @Test
        fun `getRecent - 최근 주제 조회 (카테고리 지정)`() {
            // given
            val roomId = "room123"
            val category = "동물"
            val topics = listOf("사자", "호랑이", "코끼리")
            every { listOps.range("20q:topics:$roomId:$category", 0, 19) } returns topics

            // when
            val result = store.getRecent(roomId, category, 20)

            // then
            assertThat(result).containsExactly("사자", "호랑이", "코끼리")
            verify { listOps.range("20q:topics:$roomId:$category", 0, 19) }
        }

        @Test
        fun `add - 주제 추가 및 trim (카테고리 없음)`() {
            // given
            val roomId = "room123"
            val topic = "피자"

            // when
            store.add(roomId, topic)

            // then
            verify { listOps.leftPush("20q:topics:$roomId", topic) }
            verify { listOps.trim("20q:topics:$roomId", 0, 19) }
            verify { redis.expire("20q:topics:$roomId", Duration.ofDays(30)) }
        }

        @Test
        fun `add - 주제 추가 및 trim (카테고리 지정)`() {
            // given
            val roomId = "room123"
            val category = "음식"
            val topic = "김밥"

            // when
            store.add(roomId, category, topic)

            // then
            verify { listOps.leftPush("20q:topics:$roomId:$category", topic) }
            verify { listOps.trim("20q:topics:$roomId:$category", 0, 19) }
            verify { redis.expire("20q:topics:$roomId:$category", Duration.ofDays(30)) }
        }

        @Test
        fun `clearAll - 모든 주제 삭제`() {
            // given
            val roomId = "room123"
            // clearAll은 패턴 매칭 후 삭제하므로 mock 검증 불가

            // when
            store.clearAll(roomId)

            // then
            // clearAll은 패턴 매칭 후 삭제하므로 직접 검증 불가
            // 실제 통합 테스트에서 검증해야 함
        }
    }
}
