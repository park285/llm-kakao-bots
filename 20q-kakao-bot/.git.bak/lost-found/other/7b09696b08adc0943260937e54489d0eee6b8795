package party.qwer.twentyq.service.gemini

object GeminiSchemaConverter {
    private const val FIELD_ITEMS = "items"

    fun convert(src: Map<String, Any>): Map<String, Any> = convertMap(src)

    private fun convertMap(m: Map<String, Any>): Map<String, Any> {
        val out = linkedMapOf<String, Any>()
        applySimpleFields(m, out)
        applyEnumFields(m, out)
        applyItemBounds(m, out)
        applyProperties(m, out)
        applyRequired(m, out)
        applyItems(m, out)
        applyPropertyOrdering(m, out)
        return out
    }

    private fun applySimpleFields(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val type = (m["type"] as? String)?.lowercase()
        if (type != null) out["type"] = type

        val format = m["format"] as? String
        if (format != null) out["format"] = format

        val description = m["description"] as? String
        if (description != null) out["description"] = description

        val nullable = m["nullable"] as? Boolean
        if (nullable != null) out["nullable"] = nullable
    }

    private fun applyEnumFields(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val constVal = m["const"]
        val enumVal = m["enum"] as? List<*>
        if (constVal != null) {
            out["enum"] = listOf(constVal)
        } else if (enumVal != null) {
            out["enum"] = enumVal.filterNotNull()
        }
    }

    private fun applyItemBounds(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val minItems = m["minItems"]
        if (minItems is Number) out["minItems"] = minItems.toInt()
        val maxItems = m["maxItems"]
        if (maxItems is Number) out["maxItems"] = maxItems.toInt()
    }

    private fun applyProperties(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val properties = m["properties"]
        if (properties is Map<*, *>) {
            val converted = linkedMapOf<String, Any>()
            properties.forEach { (k, v) ->
                if (k is String && v is Map<*, *>) {
                    @Suppress("UNCHECKED_CAST")
                    val vv = v as Map<String, Any>
                    converted[k] = convertMap(vv)
                }
            }
            if (converted.isNotEmpty()) out["properties"] = converted
        }
    }

    private fun applyRequired(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val required = m["required"]
        if (required is List<*>) {
            val req = required.mapNotNull { it as? String }
            if (req.isNotEmpty()) out["required"] = req
        }
    }

    private fun applyItems(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        when (val items = m[FIELD_ITEMS]) {
            is Map<*, *> -> {
                @Suppress("UNCHECKED_CAST")
                out[FIELD_ITEMS] = convertMap(items as Map<String, Any>)
            }
            is List<*> -> {
                val first = items.firstOrNull()
                if (first is Map<*, *>) {
                    @Suppress("UNCHECKED_CAST")
                    out[FIELD_ITEMS] = convertMap(first as Map<String, Any>)
                }
            }
        }
    }

    private fun applyPropertyOrdering(
        m: Map<String, Any>,
        out: MutableMap<String, Any>,
    ) {
        val propertyOrdering = m["propertyOrdering"]
        if (propertyOrdering is List<*>) {
            val po = propertyOrdering.mapNotNull { it as? String }
            if (po.isNotEmpty()) out["propertyOrdering"] = po
        }
    }
}
