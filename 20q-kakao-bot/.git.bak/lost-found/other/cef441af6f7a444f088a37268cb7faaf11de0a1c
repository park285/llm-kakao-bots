package party.qwer.twentyq.util.hint

import org.slf4j.LoggerFactory
import party.qwer.twentyq.service.KomoranService

class HintBlindRewriter {
    companion object {
        private const val BLIND_TOKEN = "[BLIND]"
        private val log = LoggerFactory.getLogger(HintBlindRewriter::class.java)

        fun extractJsonFromMarkdown(text: String): String =
            try {
                val parser =
                    com.vladsch.flexmark.parser.Parser
                        .builder()
                        .build()
                val document = parser.parse(text)

                var extracted: String? = null
                val visitor =
                    com.vladsch.flexmark.util.ast.NodeVisitor(
                        com.vladsch.flexmark.util.ast.VisitHandler(
                            com.vladsch.flexmark.ast.FencedCodeBlock::class.java,
                        ) { fc ->
                            if (extracted == null) {
                                val info = fc.info.toString().lowercase()
                                if (info.isEmpty() || info.contains("json")) {
                                    extracted = fc.contentChars.trim().toString()
                                }
                            }
                        },
                    )
                visitor.visit(document)
                (extracted ?: text).trim()
            } catch (e: Exception) {
                text.trim()
            }
    }

    fun blindTokenWithSuffix(
        hint: String,
        tokenToBlind: String,
        tokens: List<KomoranService.Token>,
    ): Pair<String, String> {
        val nounIndex = tokens.indexOfFirst { it.form == tokenToBlind }
        if (nounIndex < 0) {
            return Pair(hint.replace(tokenToBlind, BLIND_TOKEN), tokenToBlind)
        }

        val nounToken = tokens[nounIndex]
        val startPos = nounToken.position
        var endPos = startPos + nounToken.length
        if (nounIndex + 1 < tokens.size) {
            val nextToken = tokens[nounIndex + 1]
            // XS(접미사) 또는 J로 시작하는 조사 태그 포함
            if (nextToken.tag.startsWith("XS") || nextToken.tag.startsWith("J")) {
                endPos = nextToken.position + nextToken.length
                log.debug(
                    "blindTokenWithSuffix INCLUDING_SUFFIX token='{}', suffix='{}', tag='{}'",
                    tokenToBlind,
                    nextToken.form,
                    nextToken.tag,
                )
            }
        }
        val textToReplace = hint.substring(startPos, endPos)
        val blindedHint = hint.replaceFirst(textToReplace, BLIND_TOKEN)
        return Pair(blindedHint, textToReplace)
    }

    fun blindMultipleTokensWithSuffix(
        hint: String,
        tokensToBlind: List<String>,
        tokens: List<KomoranService.Token>,
    ): Pair<String, List<String>> {
        if (tokensToBlind.isEmpty()) {
            return Pair(hint, emptyList())
        }

        // 각 토큰의 position을 찾아서 역순으로 정렬 (뒤에서부터 블라인드)
        val tokenPositions =
            tokensToBlind
                .mapNotNull { tokenToBlind ->
                    val tokenObj = tokens.find { it.form == tokenToBlind }
                    if (tokenObj != null) {
                        Triple(tokenToBlind, tokenObj.position, tokenObj)
                    } else {
                        null
                    }
                }.sortedByDescending { it.second }

        var currentHint = hint
        val blindedTexts = mutableListOf<String>()

        tokenPositions.forEach { (tokenToBlind, _, _) ->
            val currentTokens =
                tokens.filter { token ->
                    val tokenIndex = currentHint.indexOf(token.form)
                    tokenIndex >= 0
                }

            val (newHint, blindedText) = blindTokenWithSuffix(currentHint, tokenToBlind, currentTokens)
            if (newHint != currentHint) {
                currentHint = newHint
                blindedTexts.add(blindedText)
            }
        }

        // 연속된 [BLIND] 토큰을 하나로 합치기
        val beforeMerge = currentHint
        currentHint = currentHint.replace(Regex("""(\[BLIND\]\s*)+"""), "[BLIND] ")

        if (beforeMerge != currentHint) {
            log.debug("blindMultipleTokensWithSuffix MERGED consecutive [BLIND] tokens")
        }

        log.info("blindMultipleTokensWithSuffix count={}, blindedTexts={}", tokensToBlind.size, blindedTexts.reversed())
        return Pair(currentHint.trim(), blindedTexts.reversed())
    }

    fun revealBlindInHint(
        hint: String,
        blindedTokens: List<String>,
    ): String {
        if (blindedTokens.isEmpty()) return hint
        return hint.replaceFirst(BLIND_TOKEN, blindedTokens.first())
    }

    fun revealBlindInHints(
        hints: List<String>,
        blindedTokensList: List<List<String>>,
    ): List<String> = hints.zip(blindedTokensList) { h, tokens -> revealBlindInHint(h, tokens) }

    fun revealTokens(
        hint: String,
        tokensToReveal: List<String>,
        count: Int,
    ): String {
        var result = hint
        tokensToReveal.take(count).forEach { token ->
            result = result.replaceFirst("[BLIND]", token)
        }
        return result
    }
}
