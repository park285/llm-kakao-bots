package party.qwer.twentyq.service.riddle

import io.mockk.coEvery
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.assertj.core.api.Assertions.assertThatThrownBy
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import party.qwer.twentyq.api.dto.QuestionHistory
import party.qwer.twentyq.config.AppProperties
import party.qwer.twentyq.model.RiddleSecret
import party.qwer.twentyq.redis.session.HistoryStore
import party.qwer.twentyq.redis.session.SecretStore
import party.qwer.twentyq.service.exception.HintLimitExceededException
import party.qwer.twentyq.service.exception.SessionNotFoundException
import party.qwer.twentyq.service.riddle.hint.HintAIClient
import party.qwer.twentyq.service.riddle.hint.HintBlindProcessor
import party.qwer.twentyq.service.riddle.hint.HintContextBuilder
import party.qwer.twentyq.service.riddle.model.HintResult

@DisplayName("HintGenerator")
class HintGeneratorTest {
    private lateinit var secretStore: SecretStore
    private lateinit var historyStore: HistoryStore
    private lateinit var contextBuilder: HintContextBuilder
    private lateinit var aiClient: HintAIClient
    private lateinit var blindProcessor: HintBlindProcessor
    private lateinit var props: AppProperties

    private lateinit var generator: HintGenerator

    @BeforeEach
    fun setUp() {
        secretStore = mockk(relaxed = true)
        historyStore = mockk(relaxed = true)
        contextBuilder = mockk(relaxed = true)
        aiClient = mockk(relaxed = true)
        blindProcessor = mockk(relaxed = true)
        props = mockk(relaxed = true)

        generator =
            HintGenerator(
                secretStore = secretStore,
                historyStore = historyStore,
                contextBuilder = contextBuilder,
                aiClient = aiClient,
                blindProcessor = blindProcessor,
                props = props,
            )
    }

    @Nested
    @DisplayName("generateHints")
    inner class GenerateHintsTest {
        @Test
        fun `세션이 없으면 SessionNotFoundException`() =
            runBlocking {
                val chatId = "chat123"

                every { secretStore.get(chatId) } returns null

                var exception: Exception? = null
                try {
                    generator.generateHints(chatId)
                } catch (e: SessionNotFoundException) {
                    exception = e
                }

                assertThat(exception).isInstanceOf(SessionNotFoundException::class.java)
            }

        @Test
        fun `블라인드 힌트 부분 공개 - 토큰이 2개 이상`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(-1, "", "OOO 과일"),
                    )

                val hintWithBlind =
                    HintBlindProcessor.HintWithBlind(
                        index = 0,
                        hintNumber = 1,
                        answer = "OOO 과일",
                        tokens = listOf("빨간색", "과일"),
                    )
                every { blindProcessor.findNext(chatId, any()) } returns hintWithBlind

                val expectedResult = HintResult.PartiallyRevealed(1, "빨간색 과일", 1)
                every { blindProcessor.revealPartial(chatId, hintWithBlind) } returns expectedResult

                val result = generator.generateHints(chatId)

                assertThat(result).isEqualTo(expectedResult)
            }

        @Test
        fun `블라인드 힌트 완전 공개 - 토큰이 1개`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(-1, "", "빨간색 OOO"),
                    )

                val hintWithBlind =
                    HintBlindProcessor.HintWithBlind(
                        index = 0,
                        hintNumber = 1,
                        answer = "빨간색 OOO",
                        tokens = listOf("과일"),
                    )
                every { blindProcessor.findNext(chatId, any()) } returns hintWithBlind

                val expectedResult = HintResult.FullyRevealed(1, "빨간색 과일")
                every { blindProcessor.revealFull(chatId, hintWithBlind) } returns expectedResult

                val result = generator.generateHints(chatId)

                assertThat(result).isEqualTo(expectedResult)
            }

        @Test
        fun `새 힌트 생성 - 블라인드 힌트 없음`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                val history =
                    listOf(
                        QuestionHistory(1, "동물인가요?", "아니요"),
                        QuestionHistory(2, "먹을 수 있나요?", "예"),
                    )
                every { historyStore.get(chatId) } returns history

                every { props.riddle.game.defaultHintLimit } returns 3
                every { props.riddle.game.bonusHintQuestionThreshold } returns 15

                every { blindProcessor.findNext(chatId, emptyList()) } returns null

                val context =
                    HintContextBuilder.Context(
                        systemPrompt = "system",
                        userPrompt = "user",
                        selectedCategory = "food",
                    )
                every { contextBuilder.build(chatId, secret, history) } returns context

                coEvery { aiClient.call("system", "user") } returns """{"hints": ["빨간색 과일"]}"""
                every { aiClient.parse(chatId, any()) } returns listOf("빨간색 과일")
                coEvery { aiClient.validateIfEnabled(chatId, listOf("빨간색 과일"), 1, "사과") } returns listOf("빨간색 과일")

                val expectedResult = HintResult.Generated(1, "OOO 과일", 1)
                coEvery { blindProcessor.applyAndSave(chatId, listOf("빨간색 과일"), "사과", "food", 1) } returns
                    expectedResult

                val result = generator.generateHints(chatId)

                assertThat(result).isEqualTo(expectedResult)
            }

        @Test
        fun `힌트 한도 초과 - HintLimitExceededException`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "Q1", "A1"),
                        QuestionHistory(2, "Q2", "A2"),
                        QuestionHistory(-1, "", "Hint1"),
                        QuestionHistory(-2, "", "Hint2"),
                        QuestionHistory(-3, "", "Hint3"),
                    )

                every { props.riddle.game.defaultHintLimit } returns 3
                every { props.riddle.game.bonusHintQuestionThreshold } returns 15

                every { blindProcessor.findNext(chatId, any()) } returns null

                var exception: Exception? = null
                try {
                    generator.generateHints(chatId)
                } catch (e: HintLimitExceededException) {
                    exception = e
                }

                assertThat(exception).isInstanceOf(HintLimitExceededException::class.java)
            }

        @Test
        fun `AI 응답이 빈 배열이면 NotAvailable 반환`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "Q1", "A1"),
                    )

                every { props.riddle.game.defaultHintLimit } returns 3
                every { props.riddle.game.bonusHintQuestionThreshold } returns 15

                every { blindProcessor.findNext(chatId, emptyList()) } returns null

                val context = HintContextBuilder.Context("system", "user", "food")
                every { contextBuilder.build(chatId, secret, any()) } returns context

                coEvery { aiClient.call(any(), any()) } returns """{"hints": []}"""
                every { aiClient.parse(chatId, any()) } returns emptyList()

                val result = generator.generateHints(chatId)

                assertThat(result).isEqualTo(HintResult.NotAvailable)
            }
    }

    @Nested
    @DisplayName("computeMaxSlots")
    inner class ComputeMaxSlotsTest {
        @Test
        fun `질문 수가 임계값 미만 - 기본 한도`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "Q1", "A1"),
                        QuestionHistory(2, "Q2", "A2"),
                        QuestionHistory(-1, "", "Hint1"),
                        QuestionHistory(-2, "", "Hint2"),
                        QuestionHistory(-3, "", "Hint3"),
                    )

                every { props.riddle.game.defaultHintLimit } returns 3
                every { props.riddle.game.bonusHintQuestionThreshold } returns 15

                every { blindProcessor.findNext(chatId, any()) } returns null

                // 질문 수 2개 (< 15) → 기본 한도 3 → 이미 3개 사용 → 한도 초과
                var exception: Exception? = null
                try {
                    generator.generateHints(chatId)
                } catch (e: HintLimitExceededException) {
                    exception = e
                }

                assertThat(exception).isInstanceOf(HintLimitExceededException::class.java)
            }

        @Test
        fun `질문 수가 임계값 이상 - 보너스 한도`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")

                every { secretStore.get(chatId) } returns secret
                val history = mutableListOf<QuestionHistory>()
                for (i in 1..15) {
                    history.add(QuestionHistory(i, "Q$i", "A$i"))
                }
                history.add(QuestionHistory(-1, "", "Hint1"))
                history.add(QuestionHistory(-2, "", "Hint2"))
                history.add(QuestionHistory(-3, "", "Hint3"))
                every { historyStore.get(chatId) } returns history

                every { props.riddle.game.defaultHintLimit } returns 3
                every { props.riddle.game.bonusHintQuestionThreshold } returns 15

                every { blindProcessor.findNext(chatId, any()) } returns null

                val context = HintContextBuilder.Context("system", "user", "food")
                every { contextBuilder.build(chatId, secret, history) } returns context

                coEvery { aiClient.call(any(), any()) } returns """{"hints": ["힌트4"]}"""
                every { aiClient.parse(chatId, any()) } returns listOf("힌트4")
                coEvery { aiClient.validateIfEnabled(any(), any(), any(), any()) } returns listOf("힌트4")

                val expectedResult = HintResult.Generated(4, "힌트4", 0)
                coEvery { blindProcessor.applyAndSave(any(), any(), any(), any(), any()) } returns expectedResult

                // 질문 수 15개 (>= 15) → 기본 한도 3 + 보너스 1 = 4 → 3개 사용 → 1개 더 생성 가능
                val result = generator.generateHints(chatId)

                assertThat(result).isEqualTo(expectedResult)
            }
    }
}
