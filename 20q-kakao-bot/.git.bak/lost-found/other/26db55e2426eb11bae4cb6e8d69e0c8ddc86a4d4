package party.qwer.twentyq.bridge.handlers

import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import party.qwer.twentyq.ai.GeminiProvider
import party.qwer.twentyq.config.AppProperties
import party.qwer.twentyq.redis.RiddleSessionRepository
import party.qwer.twentyq.service.RiddleService

@Component
@ConditionalOnProperty(prefix = "app.mqtt", name = ["enabled"], havingValue = "true", matchIfMissing = true)
class AdminHandler(
    private val appProperties: AppProperties,
    private val riddleService: RiddleService,
    private val geminiProvider: GeminiProvider,
    private val sessionRepo: RiddleSessionRepository,
    private val metaQuestionValidator: party.qwer.twentyq.service.riddle.MetaQuestionValidator,
    private val messageProvider: party.qwer.twentyq.util.GameMessageProvider,
) {
    private val log = LoggerFactory.getLogger(javaClass)

    suspend fun forceEnd(
        chatId: String,
        userId: String,
    ): String {
        log.info("HANDLE_ADMIN_FORCE_END chatId={}, userId={}", chatId, userId)
        if (!appProperties.admin.userIds.contains(userId)) {
            log.warn("ADMIN_PERMISSION_DENIED userId={}, chatId={}", userId, chatId)
            return messageProvider.get("error.no_permission")
        }

        return try {
            if (!riddleService.hasSession(chatId)) {
                return messageProvider.get("error.no_session_short")
            }

            val result = riddleService.surrender(chatId)
            log.info("ADMIN_FORCE_END_SUCCESS chatId={}, adminId={}", chatId, userId)
            messageProvider.get("admin.force_end_prefix") + result
        } catch (ex: Exception) {
            log.error("Failed to force end session", ex)
            messageProvider.get("error.generic_error")
        }
    }

    fun clearAll(
        chatId: String,
        userId: String,
    ): String {
        log.info("HANDLE_ADMIN_CLEAR_ALL chatId={}, userId={}", chatId, userId)
        if (!appProperties.admin.userIds.contains(userId)) {
            log.warn("ADMIN_PERMISSION_DENIED userId={}, chatId={}", userId, chatId)
            return messageProvider.get("error.no_permission")
        }

        return try {
            sessionRepo.clearAllData(chatId)
            log.info("ADMIN_CLEAR_ALL_SUCCESS chatId={}, adminId={}", chatId, userId)
            messageProvider.get("admin.clear_all_success")
        } catch (ex: Exception) {
            log.error("Failed to clear all data", ex)
            messageProvider.get("error.generic_error")
        }
    }

    fun refreshCache(
        chatId: String,
        userId: String,
    ): String {
        log.info("HANDLE_ADMIN_REFRESH_CACHE chatId={}, userId={}", chatId, userId)
        if (!appProperties.admin.userIds.contains(userId)) {
            log.warn("ADMIN_PERMISSION_DENIED userId={}, chatId={}", userId, chatId)
            return messageProvider.get("error.no_permission")
        }

        return try {
            val geminiSuccess = geminiProvider.refreshCaches()
            val guardSuccess = metaQuestionValidator.refreshCache()

            log.info(
                "ADMIN_REFRESH_CACHE_SUCCESS adminId={}, gemini={}, guard={}",
                userId,
                geminiSuccess,
                guardSuccess,
            )

            if (geminiSuccess && guardSuccess) {
                messageProvider.get("admin.cache_refresh_success")
            } else {
                messageProvider.get("admin.cache_refresh_failed")
            }
        } catch (ex: Exception) {
            log.error("Failed to refresh cache", ex)
            messageProvider.get("error.generic_error")
        }
    }
}
