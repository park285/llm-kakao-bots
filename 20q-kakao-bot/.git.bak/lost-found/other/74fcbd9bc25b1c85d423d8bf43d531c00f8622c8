package party.qwer.twentyq.redis.voting

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import kotlinx.coroutines.reactor.awaitSingleOrNull
import kotlinx.coroutines.runBlocking
import org.redisson.api.RedissonReactiveClient
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import party.qwer.twentyq.model.SurrenderVote
import party.qwer.twentyq.redis.RedisKeys
import java.time.Duration

@Component
@ConditionalOnProperty(
    prefix = "app.redis",
    name = ["enabled"],
    havingValue = "true",
    matchIfMissing = true,
)
class SurrenderVoteStore(
    private val redisson: RedissonReactiveClient,
    private val json: ObjectMapper,
) {
    companion object {
        private val log = LoggerFactory.getLogger(SurrenderVoteStore::class.java)
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    @Suppress("TooGenericExceptionCaught")
    fun get(roomId: String): SurrenderVote? = runBlocking { getAsync(roomId) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun getAsync(roomId: String): SurrenderVote? {
        val bucket = redisson.getBucket<String>(key(roomId))
        val data = bucket.get().awaitSingleOrNull() ?: return null
        return try {
            json.readValue<SurrenderVote>(data)
        } catch (e: Exception) {
            log.warn("PARSE_ERROR room={}, error={}", roomId, e.message)
            null
        }
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun save(
        roomId: String,
        vote: SurrenderVote,
        ttlSeconds: Long = 120,
    ) = runBlocking { saveAsync(roomId, vote, ttlSeconds) }

    suspend fun saveAsync(
        roomId: String,
        vote: SurrenderVote,
        ttlSeconds: Long = 120,
    ) {
        val data = json.writeValueAsString(vote)
        val bucket = redisson.getBucket<String>(key(roomId))
        bucket.set(data, Duration.ofSeconds(ttlSeconds)).awaitSingleOrNull()
        log.debug("SAVE room={}, vote={}, ttl={}s", roomId, vote, ttlSeconds)
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun isActive(roomId: String): Boolean = runBlocking { isActiveAsync(roomId) }

    suspend fun isActiveAsync(roomId: String): Boolean {
        val bucket = redisson.getBucket<String>(key(roomId))
        return bucket.isExists.awaitSingleOrNull() ?: false
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun approve(
        roomId: String,
        userId: String,
        ttlSeconds: Long = 120,
    ): SurrenderVote? = runBlocking { approveAsync(roomId, userId, ttlSeconds) }

    suspend fun approveAsync(
        roomId: String,
        userId: String,
        ttlSeconds: Long = 120,
    ): SurrenderVote? {
        val vote = getAsync(roomId) ?: return null
        val updated = vote.approve(userId)
        saveAsync(roomId, updated, ttlSeconds)
        log.debug(
            "APPROVE room={}, userId={}, approvals={}/{}",
            roomId,
            userId,
            updated.approvals.size,
            updated.requiredApprovals(),
        )
        return updated
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun clear(roomId: String) = runBlocking { clearAsync(roomId) }

    suspend fun clearAsync(roomId: String) {
        val bucket = redisson.getBucket<String>(key(roomId))
        bucket.delete().awaitSingleOrNull()
        log.debug("CLEAR room={}", roomId)
    }

    private fun key(roomId: String) = "${RedisKeys.SURRENDER_VOTE}:$roomId"
}
