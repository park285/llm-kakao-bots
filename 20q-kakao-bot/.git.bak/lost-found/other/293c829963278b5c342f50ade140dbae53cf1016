package party.qwer.twentyq.service

import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import party.qwer.twentyq.api.dto.HintHistory
import party.qwer.twentyq.api.dto.QuestionHistory
import party.qwer.twentyq.config.AppProperties
import party.qwer.twentyq.model.FiveScaleKo
import party.qwer.twentyq.model.RiddleCategory
import party.qwer.twentyq.model.RiddleSecret
import party.qwer.twentyq.redis.session.CategoryStore
import party.qwer.twentyq.redis.session.HistoryStore
import party.qwer.twentyq.redis.session.SessionStore
import party.qwer.twentyq.redis.tracking.HintCountStore
import party.qwer.twentyq.redis.voting.BlindedTokensStore
import party.qwer.twentyq.service.dto.AnswerResult
import party.qwer.twentyq.service.dto.AnswerSource
import party.qwer.twentyq.service.exception.SessionNotFoundException
import party.qwer.twentyq.service.riddle.HintGenerator
import party.qwer.twentyq.service.riddle.RiddleAnswerProcessor
import party.qwer.twentyq.service.riddle.RiddleCreator
import party.qwer.twentyq.service.riddle.RiddleTerminator
import party.qwer.twentyq.service.riddle.model.HintResult

@DisplayName("RiddleService 테스트")
class RiddleServiceTest {
    private lateinit var sessionStore: SessionStore
    private lateinit var historyStore: HistoryStore
    private lateinit var hintCountStore: HintCountStore
    private lateinit var blindedTokensStore: BlindedTokensStore
    private lateinit var categoryStore: CategoryStore
    private lateinit var riddleCreator: RiddleCreator
    private lateinit var riddleAnswerProcessor: RiddleAnswerProcessor
    private lateinit var hintGenerator: HintGenerator
    private lateinit var riddleTerminator: RiddleTerminator
    private lateinit var appProperties: AppProperties

    private lateinit var service: RiddleService

    @BeforeEach
    fun setup() {
        sessionStore = mockk(relaxed = true)
        historyStore = mockk(relaxed = true)
        hintCountStore = mockk(relaxed = true)
        blindedTokensStore = mockk(relaxed = true)
        categoryStore = mockk(relaxed = true)
        riddleCreator = mockk(relaxed = true)
        riddleAnswerProcessor = mockk(relaxed = true)
        hintGenerator = mockk(relaxed = true)
        riddleTerminator = mockk(relaxed = true)
        appProperties = mockk(relaxed = true)

        service =
            RiddleService(
                sessionStore,
                historyStore,
                hintCountStore,
                blindedTokensStore,
                categoryStore,
                riddleCreator,
                riddleAnswerProcessor,
                hintGenerator,
                riddleTerminator,
                appProperties,
            )
    }

    @Nested
    @DisplayName("createRiddle")
    inner class CreateRiddleTests {
        @Test
        fun `카테고리 없이 리들 생성`() =
            runBlocking {
                val chatId = "chat123"
                val expectedMessage = "새 게임이 시작되었습니다!"

                coEvery { riddleCreator.createRiddle(chatId, null) } returns expectedMessage

                val result = service.createRiddle(chatId)

                assertThat(result).isEqualTo(expectedMessage)
                coVerify(exactly = 1) { riddleCreator.createRiddle(chatId, null) }
            }

        @Test
        fun `카테고리와 함께 리들 생성`() =
            runBlocking {
                val chatId = "chat123"
                val category = "PERSON"
                val expectedMessage = "인물 카테고리로 게임이 시작되었습니다!"

                coEvery { riddleCreator.createRiddle(chatId, category) } returns expectedMessage

                val result = service.createRiddle(chatId, category)

                assertThat(result).isEqualTo(expectedMessage)
                coVerify(exactly = 1) { riddleCreator.createRiddle(chatId, category) }
            }
    }

    @Nested
    @DisplayName("generateHints")
    inner class GenerateHintsTests {
        @Test
        fun `기본 힌트 생성 (count=1)`() =
            runBlocking {
                val chatId = "chat123"
                val expectedResult = HintResult.Generated(hintNumber = 1, content = "힌트1", remainingBlinds = 3)

                coEvery { hintGenerator.generateHints(chatId, 1) } returns expectedResult

                val result = service.generateHints(chatId)

                assertThat(result).isEqualTo(expectedResult)
                coVerify(exactly = 1) { hintGenerator.generateHints(chatId, 1) }
            }

        @Test
        fun `여러 힌트 생성 (count=3)`() =
            runBlocking {
                val chatId = "chat123"
                val expectedResult = HintResult.PartiallyRevealed(hintNumber = 3, content = "힌트3", remainingBlinds = 1)

                coEvery { hintGenerator.generateHints(chatId, 3) } returns expectedResult

                val result = service.generateHints(chatId, 3)

                assertThat(result).isEqualTo(expectedResult)
                coVerify(exactly = 1) { hintGenerator.generateHints(chatId, 3) }
            }
    }

    @Nested
    @DisplayName("answer")
    inner class AnswerTests {
        @Test
        fun `정답 처리`() =
            runBlocking {
                val chatId = "chat123"
                val question = "사과인가요?"
                val expectedResult =
                    AnswerResult(
                        scale = FiveScaleKo.ALWAYS_NO,
                        source = AnswerSource.ENUM_SCHEMA_PRIMARY,
                        guardDegraded = false,
                        isWrongGuess = false,
                    )

                coEvery { riddleAnswerProcessor.processAnswer(chatId, question) } returns expectedResult

                val result = service.answer(chatId, question)

                assertThat(result).isEqualTo(expectedResult)
                coVerify(exactly = 1) { riddleAnswerProcessor.processAnswer(chatId, question) }
            }
    }

    @Nested
    @DisplayName("reveal")
    inner class RevealTests {
        @Test
        fun `정답 공개`() =
            runBlocking {
                val chatId = "chat123"
                val expectedMessage = "정답은 '사과'였습니다!"

                coEvery { riddleTerminator.reveal(chatId) } returns expectedMessage

                val result = service.reveal(chatId)

                assertThat(result).isEqualTo(expectedMessage)
                coVerify(exactly = 1) { riddleTerminator.reveal(chatId) }
            }
    }

    @Nested
    @DisplayName("surrender")
    inner class SurrenderTests {
        @Test
        fun `게임 포기`() =
            runBlocking {
                val chatId = "chat123"
                val expectedMessage = "포기하셨습니다. 정답은 '바나나'였습니다."

                coEvery { riddleTerminator.surrender(chatId) } returns expectedMessage

                val result = service.surrender(chatId)

                assertThat(result).isEqualTo(expectedMessage)
                coVerify(exactly = 1) { riddleTerminator.surrender(chatId) }
            }
    }

    @Nested
    @DisplayName("getStatus")
    inner class GetStatusTests {
        @Test
        fun `세션이 없으면 SessionNotFoundException`() {
            val chatId = "chat123"

            every { sessionStore.get(chatId) } returns null

            var exception: Exception? = null
            try {
                service.getStatus(chatId)
            } catch (e: SessionNotFoundException) {
                exception = e
            }

            assertThat(exception).isInstanceOf(SessionNotFoundException::class.java)
        }

        @Test
        fun `일반 케이스 - 질문 5개, 힌트 2개, bonusThreshold 미만`() {
            val chatId = "chat123"
            val secretJson = """{"target":"사과","category":"FOOD","intro":"맛있는 과일"}"""

            val history =
                listOf(
                    QuestionHistory(questionNumber = 1, question = "질문1", answer = "답변1"),
                    QuestionHistory(questionNumber = 2, question = "질문2", answer = "답변2"),
                    QuestionHistory(questionNumber = 3, question = "질문3", answer = "답변3"),
                    QuestionHistory(questionNumber = 4, question = "질문4", answer = "답변4"),
                    QuestionHistory(questionNumber = 5, question = "질문5", answer = "답변5"),
                    QuestionHistory(questionNumber = -1, question = "", answer = "힌트1"),
                    QuestionHistory(questionNumber = -2, question = "", answer = "힌트2"),
                )

            every { sessionStore.get(chatId) } returns secretJson
            every { historyStore.get(chatId) } returns history
            every { hintCountStore.get(chatId) } returns 2
            every { blindedTokensStore.get(chatId, any()) } returns emptyList()
            every { categoryStore.get(chatId) } returns null
            every { appProperties.riddle.game.defaultHintLimit } returns 3
            every { appProperties.riddle.game.bonusHintQuestionThreshold } returns 10

            val result = service.getStatus(chatId)

            assertThat(result.questionCount).isEqualTo(5)
            assertThat(result.questions).hasSize(5)
            assertThat(result.hints).hasSize(2)
            assertThat(result.hints[0]).isEqualTo(HintHistory(1, "힌트1"))
            assertThat(result.hints[1]).isEqualTo(HintHistory(2, "힌트2"))
            assertThat(result.hintCount).isEqualTo(2)
            assertThat(result.maxHints).isEqualTo(3)
            assertThat(result.remainingHints).isEqualTo(1) // 3 - 2 = 1
            assertThat(result.selectedCategory).isNull()
        }

        @Test
        fun `bonusThreshold 초과 케이스 - maxHints 증가`() {
            val chatId = "chat123"
            val secretJson = """{"target":"포도","category":"FOOD","intro":"과일입니다"}"""

            val history =
                List(12) { idx ->
                    QuestionHistory(
                        questionNumber = idx + 1,
                        question = "질문${idx + 1}",
                        answer = "답변${idx + 1}",
                    )
                }

            every { sessionStore.get(chatId) } returns secretJson
            every { historyStore.get(chatId) } returns history
            every { hintCountStore.get(chatId) } returns 3
            every { blindedTokensStore.get(chatId, any()) } returns emptyList()
            every { categoryStore.get(chatId) } returns null
            every { appProperties.riddle.game.defaultHintLimit } returns 3
            every { appProperties.riddle.game.bonusHintQuestionThreshold } returns 10

            val result = service.getStatus(chatId)

            assertThat(result.questionCount).isEqualTo(12)
            // bonusThreshold(10) 이상이므로 maxHints = 3 + 1 = 4
            assertThat(result.maxHints).isEqualTo(4)
            assertThat(result.remainingHints).isEqualTo(1) // 4 - 3 = 1
        }

        @Test
        fun `selectedCategory가 ANY인 케이스 - null 반환`() {
            val chatId = "chat123"
            val secretJson = """{"target":"키위","category":"ANY","intro":"뭔가 있는 것"}"""

            every { sessionStore.get(chatId) } returns secretJson
            every { historyStore.get(chatId) } returns emptyList()
            every { hintCountStore.get(chatId) } returns 0
            every { blindedTokensStore.get(chatId, any()) } returns emptyList()
            every { categoryStore.get(chatId) } returns "ANY"
            every { appProperties.riddle.game.defaultHintLimit } returns 3
            every { appProperties.riddle.game.bonusHintQuestionThreshold } returns 10

            val result = service.getStatus(chatId)

            assertThat(result.selectedCategory).isNull()
        }

        @Test
        fun `selectedCategory가 특정 카테고리인 케이스 - koreanName 반환`() {
            val chatId = "chat123"
            val secretJson = """{"target":"아인슈타인","category":"ORGANISM","intro":"유명한 인물"}"""

            every { sessionStore.get(chatId) } returns secretJson
            every { historyStore.get(chatId) } returns emptyList()
            every { hintCountStore.get(chatId) } returns 0
            every { categoryStore.get(chatId) } returns "ORGANISM"
            every { appProperties.riddle.game.defaultHintLimit } returns 3
            every { appProperties.riddle.game.bonusHintQuestionThreshold } returns 10

            val result = service.getStatus(chatId)

            assertThat(result.selectedCategory).isEqualTo(RiddleCategory.ORGANISM.koreanName)
        }

        @Test
        fun `selectedCategory가 null인 케이스`() {
            val chatId = "chat123"
            val secretJson = """{"target":"딸기","category":"FOOD","intro":"빨간 과일"}"""

            every { sessionStore.get(chatId) } returns secretJson
            every { historyStore.get(chatId) } returns emptyList()
            every { hintCountStore.get(chatId) } returns 0
            every { categoryStore.get(chatId) } returns null
            every { appProperties.riddle.game.defaultHintLimit } returns 3
            every { appProperties.riddle.game.bonusHintQuestionThreshold } returns 10

            val result = service.getStatus(chatId)

            assertThat(result.selectedCategory).isNull()
        }
    }

    @Nested
    @DisplayName("hasSession")
    inner class HasSessionTests {
        @Test
        fun `세션이 존재하면 true`() {
            val chatId = "chat123"
            val secretJson = """{"target":"수박","category":"FOOD","intro":"큰 과일"}"""

            every { sessionStore.get(chatId) } returns secretJson

            val result = service.hasSession(chatId)

            assertThat(result).isTrue()
        }

        @Test
        fun `세션이 없으면 false`() {
            val chatId = "chat123"

            every { sessionStore.get(chatId) } returns null

            val result = service.hasSession(chatId)

            assertThat(result).isFalse()
        }
    }
}
