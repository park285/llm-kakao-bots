package party.qwer.twentyq.util.hint

import com.fasterxml.jackson.module.kotlin.jacksonObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import org.slf4j.LoggerFactory
import party.qwer.twentyq.ai.AIProvider
import party.qwer.twentyq.ai.ResponseSchema
import party.qwer.twentyq.config.RiddleConfigProvider
import party.qwer.twentyq.llm.RiddlePromptManager
import party.qwer.twentyq.service.KomoranService

class HintBlindSelector(
    private val kiwiService: KomoranService,
    private val aiProvider: AIProvider,
    private val promptManager: RiddlePromptManager,
    private val riddleConfigProvider: RiddleConfigProvider,
) {
    companion object {
        private val log = LoggerFactory.getLogger(HintBlindSelector::class.java)
        private val objectMapper = jacksonObjectMapper()
    }

    suspend fun selectBlindToken(
        hint: String,
        target: String,
        category: String?,
    ): Pair<List<String>, List<KomoranService.Token>> {
        val tokens = kiwiService.analyze(hint)
        val nounTokens = tokens.filter { it.tag.startsWith("NN") }
        if (nounTokens.isEmpty()) {
            log.warn("selectBlindToken NO_NOUNS hint='{}', target='{}'", hint, target)
            return emptyList<String>() to tokens
        }

        // 개별 명사 + 연속된 명사 복합어
        val nouns =
            buildSet {
                // 개별 명사 추가
                addAll(nounTokens.map { it.form })

                // 연속된 명사를 합쳐서 복합명사 생성
                for (i in nounTokens.indices) {
                    if (i + 1 < nounTokens.size) {
                        val current = nounTokens[i]
                        val next = nounTokens[i + 1]
                        // 위치가 연속적이면 합치기
                        if (current.position + current.length == next.position) {
                            val compound = current.form + next.form
                            add(compound)
                        }
                    }
                }
            }.toList()

        val sys = promptManager.getSystemPrompt("hint_blind_judgment")
        val usrTemplate = promptManager.getUserPrompt("hint_blind_judgment")

        val tokensJson = objectMapper.writeValueAsString(nouns)
        val usr =
            usrTemplate
                .replace("{hint}", hint)
                .replace("{target}", target)
                .replace("{category}", category ?: "null")
                .replace("{tokens}", tokensJson)

        val combinedSys = promptManager.buildCombinedSystemPrompt(sys)
        val config = riddleConfigProvider.getConfig()

        val jsonSchema: Map<String, Any> =
            mapOf(
                "type" to "object",
                "additionalProperties" to false,
                "properties" to
                    mapOf(
                        "blindTokens" to
                            mapOf(
                                "type" to "array",
                                "items" to mapOf("type" to "string"),
                            ),
                    ),
                "required" to listOf("blindTokens"),
            )

        val response =
            aiProvider.generate(
                operation = "hint-blind-judgment",
                systemPrompt = combinedSys,
                userPrompt = usr,
                temperature = 0.3,
                topP = 0.9,
                schema = ResponseSchema.JsonSchema(jsonSchema),
            )

        return try {
            val cleaned = HintBlindRewriter.extractJsonFromMarkdown(response)
            val result = objectMapper.readValue<Map<String, List<String>>>(cleaned)
            val blindTokens = result["blindTokens"] ?: emptyList()
            val validTokens = blindTokens.filter { hint.contains(it) }
            log.info("selectBlindToken LLM_RESPONSE blindTokens={}, validTokens={}", blindTokens, validTokens)
            validTokens to tokens
        } catch (e: Exception) {
            log.warn("selectBlindToken JSON_PARSE_FAILED error={}, returning empty list", e.message)
            emptyList<String>() to tokens
        }
    }
}
