package party.qwer.twentyq.service

import io.mockk.coEvery
import io.mockk.mockk
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test

/**
 * hasComplexTypo() 로직 테스트
 *
 * Komoran 기반 통계적 오타 감지
 */
class ComplexTypoDetectionTest {
    private lateinit var komoranService: KomoranService
    private lateinit var normalizeService: NormalizeService

    @BeforeEach
    fun setUp() {
        komoranService = KomoranService(mockk(relaxed = true))
        komoranService.init()

        val aiProvider = mockk<party.qwer.twentyq.ai.AIProvider>(relaxed = true)
        val promptManager = mockk<party.qwer.twentyq.llm.RiddlePromptManager>(relaxed = true)
        val riddleConfigProvider = mockk<party.qwer.twentyq.config.RiddleConfigProvider>(relaxed = true)

        coEvery { promptManager.getSystemPrompt("normalize") } returns "system"
        coEvery { promptManager.getUserPrompt("normalize") } returns "{question}"
        coEvery { promptManager.buildCombinedSystemPrompt(any()) } returns "combined"
        coEvery { riddleConfigProvider.getConfig() } returns mockConfig()
        coEvery { aiProvider.generate(any(), any(), any(), any(), any(), any()) } returns """{"normalized": "교정됨"}"""

        normalizeService =
            NormalizeService(
                komoranService,
                aiProvider,
                promptManager,
                riddleConfigProvider,
                mockk(relaxed = true),
                mockk(relaxed = true),
                cacheEnabled = false,
            )
    }

    @Test
    fun `should NOT detect complex typo for normal text`() =
        runBlocking {
            val normalTexts =
                listOf(
                    "전자기기인가요?",
                    "먹었어요",
                    "살아있나요",
                    "괜찮아요",
                )

            println("\n=== 정상 텍스트 (LLM 스킵 예상) ===")
            normalTexts.forEach { text ->
                val tokens = komoranService.analyze(text)
                val result = normalizeService.normalize(text)

                println("[TEXT] $text")
                println("  Tokens: ${tokens.size}, Avg Length: ${tokens.map { it.length }.average()}")
                println("  Unknown: ${tokens.count { it.tag.startsWith("UNK") }}")
                println("  Result: ${if (result.normalized == text) "SKIP (no LLM)" else "LLM called"}")
            }
        }

    @Test
    fun `should detect complex typo - incomplete hangul`() =
        runBlocking {
            val text = "ㄱㄱㄱ나요?"

            println("\n=== 불완전한 한글 ===")
            println("[TEXT] $text")

            val tokens = komoranService.analyze(text)
            println("  Tokens: ${tokens.map { "${it.form}/${it.tag}" }}")
            println("  완성형 비율: ${text.count { it in '가'..'힣' }.toDouble() / text.length}")

            val result = normalizeService.normalize(text)
            println("  Result: ${result.normalized}")
            println("  LLM called: ${result.normalized != text}")

            assertThat(result.normalized).isNotEqualTo(text) // LLM 호출됨
        }

    @Test
    fun `should detect complex typo - high unknown ratio`() =
        runBlocking {
            val text = "asdfㄱㄴㄷ나요"

            println("\n=== Unknown 태그 많음 ===")
            println("[TEXT] $text")

            val tokens = komoranService.analyze(text)
            val unknownRatio = tokens.count { it.tag.startsWith("UNK") }.toDouble() / tokens.size
            println("  Tokens: ${tokens.map { "${it.form}/${it.tag}" }}")
            println("  Unknown ratio: $unknownRatio")

            val result = normalizeService.normalize(text)
            println("  Result: ${result.normalized}")
            println("  LLM called: ${result.normalized != text}")
        }

    @Test
    fun `should detect complex typo - low avg token length`() =
        runBlocking {
            val text = "ㅏㅏㅏㅏㅏㅏㅏㅏ"

            println("\n=== 토큰 평균 길이 낮음 ===")
            println("[TEXT] $text")

            val tokens = komoranService.analyze(text)
            val avgLength = tokens.map { it.length }.average()
            println("  Tokens: ${tokens.size}, Avg Length: $avgLength")
            println("  Tokens: ${tokens.map { "${it.form}/${it.tag}" }}")

            val result = normalizeService.normalize(text)
            println("  Result: ${result.normalized}")
            println("  LLM called: ${result.normalized != text}")
        }

    @Test
    fun `should allow emoticons`() =
        runBlocking {
            val text = "맞아요ㅋㅋㅋ"

            println("\n=== 이모티콘 허용 ===")
            println("[TEXT] $text")

            val tokens = komoranService.analyze(text)
            println("  Tokens: ${tokens.map { "${it.form}/${it.tag}" }}")

            val result = normalizeService.normalize(text)
            println("  Result: ${result.normalized}")
            println("  LLM skipped: ${result.normalized == text}")

            // ㅋㅋㅋ는 이모티콘이므로 LLM 호출 안됨
            assertThat(result.normalized).isEqualTo(text)
        }

    private fun mockConfig() =
        party.qwer.twentyq.config.RiddleConfigProvider.ProviderConfig(
            temperature =
                party.qwer.twentyq.config.RiddleConfigProvider.TempConfig(
                    create = 0.9,
                    hints = 0.7,
                    answer = 0.2,
                    reveal = 0.6,
                    normalize = 0.3,
                    synonymCheck = 0.1,
                ),
            topP =
                party.qwer.twentyq.config.RiddleConfigProvider.TopPConfig(
                    create = 0.95,
                    hints = 0.9,
                    answer = 0.5,
                    reveal = 0.9,
                    normalize = 0.9,
                    synonymCheck = 0.5,
                ),
        )
}
