package party.qwer.twentyq.service

import com.fasterxml.jackson.databind.ObjectMapper
import org.slf4j.LoggerFactory
import org.springframework.beans.factory.annotation.Value
import org.springframework.stereotype.Component
import org.springframework.web.client.RestClient
import org.springframework.web.client.RestClientResponseException
import party.qwer.twentyq.ai.ResponseSchema
import party.qwer.twentyq.service.gemini.GeminiRequestBuilder
import party.qwer.twentyq.service.gemini.GeminiRequestPayload
import party.qwer.twentyq.service.gemini.GeminiResponseParser
import party.qwer.twentyq.service.gemini.GenerationOptions

@Component
class GeminiApiClient(
    @param:Value("\${app.ai.gemini.base-url:https://generativelanguage.googleapis.com}")
    private val baseUrl: String,
    private val keyProvider: GeminiApiKeyProvider,
    private val cacheManager: GeminiCacheManager,
    private val objectMapper: ObjectMapper,
    private val requestBuilder: GeminiRequestBuilder,
    private val responseParser: GeminiResponseParser,
) {
    companion object {
        private val log = LoggerFactory.getLogger(GeminiApiClient::class.java)
    }

    private val restClient =
        RestClient
            .builder()
            .baseUrl(baseUrl)
            .build()

    @Suppress("LongParameterList")
    fun generateWithThinking(
        model: String,
        systemPrompt: String,
        userPrompt: String,
        temperature: Double,
        topP: Double,
        thinkingBudget: Int,
        schema: ResponseSchema? = null,
    ): String {
        val effectiveBudget = effectiveThinkingBudget(model, thinkingBudget)
        val requestBody =
            requestBuilder.buildRequest(
                GeminiRequestPayload(
                    systemPrompt = systemPrompt,
                    userPrompt = userPrompt,
                    options =
                        GenerationOptions(
                            temperature = temperature,
                            topP = topP,
                            thinkingBudget = effectiveBudget,
                            schema = schema,
                        ),
                ),
            )

        log.info(
            "GeminiApiClient GENERATE model={}, thinkingBudgetBase={}, thinkingBudgetEffective={}",
            model,
            thinkingBudget,
            effectiveBudget,
        )

        val response =
            keyProvider.withKeyRetry { k ->
                restClient
                    .post()
                    .uri("/v1beta/models/{model}:generateContent?key={apiKey}", model, k)
                    .header("Content-Type", "application/json")
                    .body(requestBody)
                    .retrieve()
                    .body(String::class.java)
                    ?: error("Empty response from Gemini API")
            }

        return responseParser.extractText(response)
    }

    @Suppress("LongParameterList")
    fun generateWithCache(
        model: String,
        cacheId: String,
        userPrompt: String,
        temperature: Double,
        topP: Double,
        thinkingBudget: Int = 0,
        schema: ResponseSchema? = null,
        apiKey: String? = null,
    ): String {
        val effectiveBudget = effectiveThinkingBudget(model, thinkingBudget)
        log.info(
            "GeminiApiClient GENERATE_WITH_CACHE model={}, cacheId={}, thinkingBudgetBase={}, thinkingBudgetEffective={}",
            model,
            cacheId,
            thinkingBudget,
            effectiveBudget,
        )

        val requestBody =
            requestBuilder.buildRequest(
                GeminiRequestPayload(
                    systemPrompt = null,
                    userPrompt = userPrompt,
                    cacheId = cacheId,
                    options =
                        GenerationOptions(
                            temperature = temperature,
                            topP = topP,
                            thinkingBudget = effectiveBudget,
                            schema = schema,
                        ),
                ),
            )

        val response = executeGenerateRequest(model, requestBody, apiKey)
        return responseParser.extractText(response)
    }

    @Suppress("LongParameterList")
    fun generate(
        model: String = "gemini-2.5-flash",
        systemPrompt: String,
        userPrompt: String,
        temperature: Double = 1.0,
        topP: Double = 0.95,
        maxTokens: Int? = null,
        schema: ResponseSchema? = null,
    ): String {
        val genCfg =
            linkedMapOf<String, Any>(
                "temperature" to temperature,
                "topP" to topP,
            )
        maxTokens?.let { genCfg["maxOutputTokens"] = it }
        when (schema) {
            is ResponseSchema.Enum -> {
                genCfg["responseMimeType"] = "text/x.enum"
                genCfg["responseSchema"] =
                    mapOf(
                        "type" to "STRING",
                        "enum" to schema.values,
                    )
            }
            is ResponseSchema.JsonSchema -> {
                genCfg["responseMimeType"] = "application/json"
                genCfg["responseSchema"] = requestBuilder.toGeminiSchema(schema.schema)
            }
            else -> { /* no-op */ }
        }

        val requestBody =
            mapOf(
                "contents" to
                    listOf(
                        mapOf(
                            "parts" to
                                listOf(
                                    mapOf("text" to "$systemPrompt\n\n$userPrompt"),
                                ),
                        ),
                    ),
                "generationConfig" to genCfg,
            )

        log.info("GeminiApiClient GENERATE model={}, temp={}, topP={}", model, temperature, topP)

        val response =
            keyProvider.withKeyRetry { k ->
                restClient
                    .post()
                    .uri("/v1beta/models/{model}:generateContent?key={apiKey}", model, k)
                    .header("Content-Type", "application/json")
                    .body(requestBody)
                    .retrieve()
                    .body(String::class.java)
                    ?: error("Empty response from Gemini API")
            }

        return responseParser.extractText(response)
    }

    fun effectiveThinkingBudget(
        model: String,
        baseBudget: Int,
    ): Int {
        if (baseBudget <= 0) return 0
        val normalized = model.substringAfterLast("/")
        val scaled =
            if (isFlashModel(normalized)) {
                (baseBudget.toLong() * 3L) / 2L
            } else {
                baseBudget.toLong()
            }
        return scaled.coerceAtMost(Int.MAX_VALUE.toLong()).toInt()
    }

    private fun isFlashModel(normalizedModel: String): Boolean = normalizedModel.contains("flash", ignoreCase = true)

    // Helper: REST POST 호출 패턴 통합
    private fun executeGenerateRequest(
        model: String,
        requestBody: Map<String, Any>,
        apiKey: String? = null,
    ): String =
        if (apiKey != null) {
            keyProvider.withSpecificKey(apiKey) { k ->
                restClient
                    .post()
                    .uri("/v1beta/models/{model}:generateContent?key={apiKey}", model, k)
                    .header("Content-Type", "application/json")
                    .body(requestBody)
                    .retrieve()
                    .body(String::class.java)
                    ?: error("Empty response from Gemini API")
            }
        } else {
            keyProvider.withKeyRetry { k ->
                restClient
                    .post()
                    .uri("/v1beta/models/{model}:generateContent?key={apiKey}", model, k)
                    .header("Content-Type", "application/json")
                    .body(requestBody)
                    .retrieve()
                    .body(String::class.java)
                    ?: error("Empty response from Gemini API")
            }
        }

    fun embedText(
        text: String,
        outputDimension: Int = 1536,
    ): FloatArray {
        log.debug("GeminiApiClient EMBED_TEXT length={}, dimension={}", text.length, outputDimension)

        val requestBody =
            mapOf(
                "model" to "models/gemini-embedding-001",
                "content" to
                    mapOf(
                        "parts" to listOf(mapOf("text" to text)),
                    ),
                "outputDimensionality" to outputDimension,
            )

        val response =
            keyProvider.withKeyRetry { k ->
                try {
                    restClient
                        .post()
                        .uri("/v1beta/models/gemini-embedding-001:embedContent?key={apiKey}", k)
                        .header("Content-Type", "application/json")
                        .body(requestBody)
                        .retrieve()
                        .body(String::class.java)
                        ?: error("Empty response from Gemini Embedding API")
                } catch (e: RestClientResponseException) {
                    log.error("Gemini Embedding API error: status={}, body={}", e.statusCode, e.responseBodyAsString)
                    throw e
                }
            }

        return parseEmbeddingResponse(response)
    }

    @Suppress("TooGenericExceptionCaught", "UseCheckOrError")
    private fun parseEmbeddingResponse(response: String): FloatArray {
        try {
            val jsonNode = objectMapper.readTree(response)
            val valuesNode =
                jsonNode.get("embedding")?.get("values")
                    ?: throw IllegalStateException("No embedding.values in response")

            return FloatArray(valuesNode.size()) { i ->
                valuesNode.get(i).asDouble().toFloat()
            }
        } catch (e: Exception) {
            log.error("Failed to parse embedding response: {}", e.message)
            throw IllegalStateException("Failed to parse embedding response", e)
        }
    }
}
