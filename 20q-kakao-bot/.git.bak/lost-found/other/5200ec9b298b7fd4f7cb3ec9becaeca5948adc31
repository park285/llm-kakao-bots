package party.qwer.twentyq.redis.voting

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.kotlin.readValue
import kotlinx.coroutines.reactor.awaitSingleOrNull
import kotlinx.coroutines.runBlocking
import org.redisson.api.RedissonReactiveClient
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import party.qwer.twentyq.config.AppProperties
import reactor.core.publisher.Flux
import java.time.Duration

@Component
@ConditionalOnProperty(
    prefix = "app.redis",
    name = ["enabled"],
    havingValue = "true",
    matchIfMissing = true,
)
class BlindedTokensStore(
    private val redisson: RedissonReactiveClient,
    private val props: AppProperties,
    private val json: ObjectMapper,
) {
    companion object {
        private val log = LoggerFactory.getLogger(BlindedTokensStore::class.java)
    }

    suspend fun save(
        roomId: String,
        hintNumber: Int,
        tokens: List<String>,
    ) {
        val data = json.writeValueAsString(tokens)
        val ttl = Duration.ofMinutes(props.redis.sessionTtlMinutes)
        val bucket = redisson.getBucket<String>(key(roomId, hintNumber))
        bucket.set(data, ttl).awaitSingleOrNull()
        log.debug("SAVE room={}, hint={}, tokens={}", roomId, hintNumber, tokens)
    }

    // Blocking wrapper
    fun get(
        roomId: String,
        hintNumber: Int,
    ): List<String> = runBlocking { getAsync(roomId, hintNumber) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun getAsync(
        roomId: String,
        hintNumber: Int,
    ): List<String> {
        val bucket = redisson.getBucket<String>(key(roomId, hintNumber))
        val data = bucket.get().awaitSingleOrNull() ?: return emptyList()
        return try {
            json.readValue<List<String>>(data)
        } catch (e: Exception) {
            log.warn("PARSE_ERROR room={}, hint={}, error={}", roomId, hintNumber, e.message)
            emptyList()
        }
    }

    suspend fun update(
        roomId: String,
        hintNumber: Int,
        tokens: List<String>,
    ) {
        if (tokens.isEmpty()) {
            deleteAsync(roomId, hintNumber)
            return
        }
        val data = json.writeValueAsString(tokens)
        val ttl = Duration.ofMinutes(props.redis.sessionTtlMinutes)
        val bucket = redisson.getBucket<String>(key(roomId, hintNumber))
        bucket.set(data, ttl).awaitSingleOrNull()
        log.debug("UPDATE room={}, hint={}, tokens={}", roomId, hintNumber, tokens.size)
    }

    fun delete(
        roomId: String,
        hintNumber: Int,
    ) = runBlocking { deleteAsync(roomId, hintNumber) }

    suspend fun deleteAsync(
        roomId: String,
        hintNumber: Int,
    ) {
        redisson.getBucket<String>(key(roomId, hintNumber)).delete().awaitSingleOrNull()
        log.debug("DELETE room={}, hint={}", roomId, hintNumber)
    }

    fun deleteAll(roomId: String) = runBlocking { deleteAllAsync(roomId) }

    suspend fun deleteAllAsync(roomId: String) {
        val pattern = "${party.qwer.twentyq.redis.RedisKeys.BLINDED_TOKENS}:$roomId:*"
        val keys =
            redisson.keys
                .getKeysByPattern(pattern)
                .collectList()
                .awaitSingleOrNull() ?: emptyList()
        if (keys.isNotEmpty()) {
            Flux
                .fromIterable(keys)
                .flatMap { redisson.getBucket<String>(it).delete() }
                .then()
                .awaitSingleOrNull()
            log.debug("DELETE_ALL room={}, deletedKeys={}", roomId, keys.size)
        }
    }

    suspend fun setTtl(
        roomId: String,
        hintNumber: Int,
        ttl: Duration,
    ) {
        redisson.getBucket<String>(key(roomId, hintNumber)).expire(ttl).awaitSingleOrNull()
    }

    private fun key(
        roomId: String,
        hintNumber: Int,
    ) = "${party.qwer.twentyq.redis.RedisKeys.BLINDED_TOKENS}:$roomId:$hintNumber"
}
