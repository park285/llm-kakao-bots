package party.qwer.twentyq.redis.session

import kotlinx.coroutines.reactor.awaitSingleOrNull
import kotlinx.coroutines.runBlocking
import org.redisson.api.RedissonReactiveClient
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import party.qwer.twentyq.config.AppProperties
import party.qwer.twentyq.redis.RedisKeys
import java.time.Duration

@Component
@ConditionalOnProperty(
    prefix = "app.redis",
    name = ["enabled"],
    havingValue = "true",
    matchIfMissing = true,
)
class SessionStore(
    private val redisson: RedissonReactiveClient,
    private val props: AppProperties,
) {
    companion object {
        private val log = LoggerFactory.getLogger(SessionStore::class.java)
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun get(roomId: String): String? = runBlocking { getAsync(roomId) }

    suspend fun getAsync(roomId: String): String? {
        val bucket = redisson.getBucket<String>(key(roomId))
        val data = bucket.get().awaitSingleOrNull()
        log.debug("GET room={}, exists={}, size={}", roomId, data != null, data?.length ?: 0)
        return data
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun save(
        roomId: String,
        data: String,
    ) = runBlocking { saveAsync(roomId, data) }

    suspend fun saveAsync(
        roomId: String,
        data: String,
    ) {
        val ttl = Duration.ofMinutes(props.redis.sessionTtlMinutes.toLong())
        val bucket = redisson.getBucket<String>(key(roomId))
        bucket.set(data, ttl).awaitSingleOrNull()
        log.debug("SAVE room={}, size={}, ttl={}min", roomId, data.length, props.redis.sessionTtlMinutes)
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun delete(roomId: String) = runBlocking { deleteAsync(roomId) }

    suspend fun deleteAsync(roomId: String) {
        val bucket = redisson.getBucket<String>(key(roomId))
        bucket.delete().awaitSingleOrNull()
        log.debug("DELETE room={}", roomId)
    }

    // Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
    fun setTtl(
        roomId: String,
        ttl: Duration,
    ): Boolean = runBlocking { setTtlAsync(roomId, ttl) }

    suspend fun setTtlAsync(
        roomId: String,
        ttl: Duration,
    ): Boolean {
        val bucket = redisson.getBucket<String>(key(roomId))
        val result = bucket.expire(ttl).awaitSingleOrNull() ?: false
        log.debug("TTL room={}, ttl={}, success={}", roomId, ttl, result)
        return result
    }

    private fun key(roomId: String) = "${RedisKeys.SESSION}:$roomId"
}
