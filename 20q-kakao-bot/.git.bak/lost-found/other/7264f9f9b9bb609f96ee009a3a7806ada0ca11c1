package party.qwer.twentyq.service.riddle.hint

import io.mockk.Runs
import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.just
import io.mockk.mockk
import io.mockk.verify
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Test
import party.qwer.twentyq.api.dto.QuestionHistory
import party.qwer.twentyq.redis.session.HistoryStore
import party.qwer.twentyq.redis.tracking.HintCountStore
import party.qwer.twentyq.redis.voting.BlindedTokensStore
import party.qwer.twentyq.service.riddle.model.HintResult
import party.qwer.twentyq.util.hint.HintBlindService

@DisplayName("HintBlindProcessor 테스트")
class HintBlindProcessorTest {
    private lateinit var historyStore: HistoryStore
    private lateinit var hintCountStore: HintCountStore
    private lateinit var blindedTokensStore: BlindedTokensStore
    private lateinit var blindService: HintBlindService
    private lateinit var processor: HintBlindProcessor

    @BeforeEach
    fun setUp() {
        historyStore = mockk(relaxed = true)
        hintCountStore = mockk(relaxed = true)
        blindedTokensStore = mockk(relaxed = true)
        blindService = mockk(relaxed = true)
        processor =
            HintBlindProcessor(
                historyStore = historyStore,
                hintCountStore = hintCountStore,
                blindedTokensStore = blindedTokensStore,
                blindService = blindService,
            )
    }

    @Test
    @DisplayName("findNext는 블라인드 토큰이 있는 첫 번째 힌트를 반환한다")
    fun shouldReturnFirstHintWithBlindedTokens() {
        // given
        val roomId = "room123"
        val hints =
            listOf(
                QuestionHistory(questionNumber = -1, question = "힌트 #1", answer = "첫 번째 힌트"),
                QuestionHistory(questionNumber = -2, question = "힌트 #2", answer = "두 번째 힌트"),
            )
        every { blindedTokensStore.get(roomId, 1) } returns emptyList()
        every { blindedTokensStore.get(roomId, 2) } returns listOf("토큰1", "토큰2")

        // when
        val result = processor.findNext(roomId, hints)

        // then
        assertThat(result).isNotNull
        assertThat(result?.index).isEqualTo(1)
        assertThat(result?.hintNumber).isEqualTo(2)
        assertThat(result?.answer).isEqualTo("두 번째 힌트")
        assertThat(result?.tokens).containsExactly("토큰1", "토큰2")
    }

    @Test
    @DisplayName("findNext는 블라인드 토큰이 없으면 null을 반환한다")
    fun shouldReturnNullWhenNoBlindedTokensExist() {
        // given
        val roomId = "room123"
        val hints =
            listOf(
                QuestionHistory(questionNumber = -1, question = "힌트 #1", answer = "첫 번째 힌트"),
                QuestionHistory(questionNumber = -2, question = "힌트 #2", answer = "두 번째 힌트"),
            )
        every { blindedTokensStore.get(roomId, any()) } returns emptyList()

        // when
        val result = processor.findNext(roomId, hints)

        // then
        assertThat(result).isNull()
    }

    @Test
    @DisplayName("findNext는 빈 힌트 목록에 대해 null을 반환한다")
    fun shouldReturnNullForEmptyHintsList() {
        // given
        val roomId = "room123"
        val hints = emptyList<QuestionHistory>()

        // when
        val result = processor.findNext(roomId, hints)

        // then
        assertThat(result).isNull()
    }

    @Test
    @DisplayName("revealPartial은 토큰을 부분적으로 공개하고 스토어를 업데이트한다")
    fun shouldRevealPartiallyAndUpdateStores() {
        // given
        val roomId = "room123"
        val hint =
            HintBlindProcessor.HintWithBlind(
                index = 0,
                hintNumber = 1,
                answer = "원본 힌트 답변",
                tokens = listOf("토큰1", "토큰2", "토큰3"),
            )
        val revealResult =
            HintBlindService.RevealResult(
                updatedHint = "부분 공개된 힌트",
                revealedTokens = listOf("토큰1", "토큰2"),
                remainingTokens = listOf("토큰3"),
            )
        every { blindService.revealTokens(hint.answer, hint.tokens, 2) } returns revealResult
        every { historyStore.updateAt(any(), any(), any(), any(), any()) } just Runs
        every { blindedTokensStore.update(any(), any(), any()) } just Runs

        // when
        val result = processor.revealPartial(roomId, hint)

        // then
        assertThat(result).isInstanceOf(HintResult.PartiallyRevealed::class.java)
        assertThat(result.hintNumber).isEqualTo(1)
        assertThat(result.content).isEqualTo("부분 공개된 힌트")
        assertThat(result.remainingBlinds).isEqualTo(1)

        verify(exactly = 1) {
            historyStore.updateAt(
                roomId = roomId,
                index = 0,
                questionNumber = -1,
                question = "힌트 #1",
                answer = "부분 공개된 힌트",
            )
        }
        verify(exactly = 1) {
            blindedTokensStore.update(roomId, 1, listOf("토큰3"))
        }
    }

    @Test
    @DisplayName("revealPartial은 토큰이 1개만 있어도 최소 1개는 공개한다")
    fun shouldRevealAtLeastOneTokenEvenIfOnlyOneExists() {
        // given
        val roomId = "room123"
        val hint =
            HintBlindProcessor.HintWithBlind(
                index = 0,
                hintNumber = 1,
                answer = "원본 힌트",
                tokens = listOf("토큰1"),
            )
        val revealResult =
            HintBlindService.RevealResult(
                updatedHint = "공개된 힌트",
                revealedTokens = listOf("토큰1"),
                remainingTokens = emptyList(),
            )
        every { blindService.revealTokens(hint.answer, hint.tokens, 1) } returns revealResult

        // when
        val result = processor.revealPartial(roomId, hint)

        // then
        verify(exactly = 1) {
            blindService.revealTokens(hint.answer, hint.tokens, 1)
        }
    }

    @Test
    @DisplayName("revealFull은 모든 토큰을 공개하고 블라인드 토큰을 삭제한다")
    fun shouldRevealFullyAndDeleteBlindedTokens() {
        // given
        val roomId = "room123"
        val hint =
            HintBlindProcessor.HintWithBlind(
                index = 1,
                hintNumber = 2,
                answer = "원본 힌트",
                tokens = listOf("토큰1", "토큰2"),
            )
        val revealResult =
            HintBlindService.RevealResult(
                updatedHint = "완전 공개된 힌트",
                revealedTokens = listOf("토큰1", "토큰2"),
                remainingTokens = emptyList(),
            )
        every { blindService.revealTokens(hint.answer, hint.tokens, 2) } returns revealResult
        every { historyStore.updateAt(any(), any(), any(), any(), any()) } just Runs
        every { blindedTokensStore.delete(any(), any()) } just Runs

        // when
        val result = processor.revealFull(roomId, hint)

        // then
        assertThat(result).isInstanceOf(HintResult.FullyRevealed::class.java)
        assertThat(result.hintNumber).isEqualTo(2)
        assertThat(result.content).isEqualTo("완전 공개된 힌트")

        verify(exactly = 1) {
            historyStore.updateAt(
                roomId = roomId,
                index = 1,
                questionNumber = -2,
                question = "힌트 #2",
                answer = "완전 공개된 힌트",
            )
        }
        verify(exactly = 1) {
            blindedTokensStore.delete(roomId, 2)
        }
    }

    @Test
    @DisplayName("applyAndSave는 블라인드 처리 후 힌트를 저장한다")
    fun shouldApplyBlindAndSaveHint() =
        runBlocking {
            // given
            val roomId = "room123"
            val hints = listOf("첫 번째 힌트", "두 번째 힌트")
            val target = "정답"
            val selectedCategory = "동물"
            val nextHintNumber = 3
            val blindResults =
                listOf(
                    "블라인드된 첫 번째 힌트" to listOf("토큰1", "토큰2"),
                    "블라인드된 두 번째 힌트" to listOf("토큰3"),
                )

            coEvery {
                blindService.blindTargetInHints(hints, target, selectedCategory)
            } returns blindResults
            every { hintCountStore.increment(roomId) } returns 3L
            every { blindedTokensStore.save(any(), any(), any()) } returns Unit
            every { historyStore.add(any(), any(), any(), any()) } returns Unit

            // when
            val result = processor.applyAndSave(roomId, hints, target, selectedCategory, nextHintNumber)

            // then
            assertThat(result).isInstanceOf(HintResult.Generated::class.java)
            val generated = result as HintResult.Generated
            assertThat(generated.hintNumber).isEqualTo(3)
            assertThat(generated.content).isEqualTo("블라인드된 첫 번째 힌트")
            assertThat(generated.remainingBlinds).isEqualTo(2)

            coVerify(exactly = 1) {
                blindService.blindTargetInHints(hints, target, selectedCategory)
            }
            verify(exactly = 1) { hintCountStore.increment(roomId) }
            verify(exactly = 1) {
                blindedTokensStore.save(roomId, 3, listOf("토큰1", "토큰2"))
            }
            verify(exactly = 1) {
                historyStore.add(
                    roomId = roomId,
                    questionNumber = -3,
                    question = "힌트 #3",
                    answer = "블라인드된 첫 번째 힌트",
                )
            }
        }

    @Test
    @DisplayName("applyAndSave는 블라인드 토큰이 없으면 삭제 처리한다")
    fun shouldDeleteBlindedTokensWhenNoTokensRemain() =
        runBlocking {
            // given
            val roomId = "room123"
            val hints = listOf("힌트")
            val target = "정답"
            val nextHintNumber = 1
            val blindResults = listOf("완전 공개 힌트" to emptyList<String>())

            coEvery {
                blindService.blindTargetInHints(hints, target, null)
            } returns blindResults
            every { hintCountStore.increment(roomId) } returns 1L
            every { blindedTokensStore.delete(any(), any()) } returns Unit
            every { historyStore.add(any(), any(), any(), any()) } returns Unit

            // when
            val result = processor.applyAndSave(roomId, hints, target, null, nextHintNumber)

            // then
            assertThat(result).isInstanceOf(HintResult.Generated::class.java)
            val generated = result as HintResult.Generated
            assertThat(generated.remainingBlinds).isEqualTo(0)

            verify(exactly = 0) { blindedTokensStore.save(any(), any(), any()) }
            verify(exactly = 1) { blindedTokensStore.delete(roomId, 1) }
        }

    @Test
    @DisplayName("applyAndSave는 블라인드 결과가 비어있으면 NotAvailable을 반환한다")
    fun shouldReturnNotAvailableWhenBlindResultsAreEmpty() =
        runBlocking {
            // given
            val roomId = "room123"
            val hints = listOf("힌트")
            val target = "정답"
            val nextHintNumber = 1

            coEvery {
                blindService.blindTargetInHints(hints, target, null)
            } returns emptyList()

            // when
            val result = processor.applyAndSave(roomId, hints, target, null, nextHintNumber)

            // then
            assertThat(result).isEqualTo(HintResult.NotAvailable)

            verify(exactly = 0) { hintCountStore.increment(any()) }
            verify(exactly = 0) { blindedTokensStore.save(any(), any(), any()) }
            verify(exactly = 0) { blindedTokensStore.delete(any(), any()) }
            verify(exactly = 0) { historyStore.add(any(), any(), any(), any()) }
        }
}
