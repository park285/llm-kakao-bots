package party.qwer.twentyq.util

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.dataformat.yaml.YAMLFactory
import org.slf4j.LoggerFactory
import org.springframework.core.io.ClassPathResource
import org.springframework.stereotype.Component
import javax.annotation.PostConstruct

@Component
class GameMessageProvider {
    companion object {
        private val log = LoggerFactory.getLogger(GameMessageProvider::class.java)
        private const val MESSAGE_FILE_PATH = "messages/game-messages.yml"
    }

    private val objectMapper = ObjectMapper(YAMLFactory())
    private lateinit var messages: Map<String, Any>

    @PostConstruct
    fun init() {
        try {
            val resource = ClassPathResource(MESSAGE_FILE_PATH)
            val tree = objectMapper.readTree(resource.inputStream)
            val toonNode =
                tree.get("toon")
                    ?: throw IllegalStateException("Missing 'toon' root node in $MESSAGE_FILE_PATH")

            @Suppress("UNCHECKED_CAST")
            messages = objectMapper.convertValue(toonNode, Map::class.java) as Map<String, Any>

            log.info("GameMessageProvider initialized from classpath:{}", MESSAGE_FILE_PATH)
        } catch (
            @Suppress("TooGenericExceptionCaught") e: Exception,
        ) {
            log.error("Failed to load game messages from {}: {}", MESSAGE_FILE_PATH, e.message, e)
            throw IllegalStateException("Cannot load game messages", e)
        }
    }

    fun get(
        key: String,
        vararg params: Pair<String, Any>,
    ): String {
        val template = getNestedValue(messages, key) ?: return key
        return params.fold(template) { acc, (k, v) ->
            acc.replace("{$k}", v.toString())
        }
    }

    @Suppress("UNCHECKED_CAST")
    private fun getNestedValue(
        map: Map<String, Any>,
        path: String,
    ): String? {
        val keys = path.split(".")
        var current: Any? = map

        for (key in keys) {
            when (current) {
                is Map<*, *> -> current = (current as Map<String, Any>)[key]
                else -> return null
            }
        }

        return when (current) {
            is String -> current
            is List<*> -> current.joinToString(", ") { it.toString() }
            else -> current?.toString()
        }
    }
}
