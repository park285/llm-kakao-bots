package party.qwer.twentyq.service

import com.fasterxml.jackson.databind.ObjectMapper
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.condition.EnabledIfEnvironmentVariable

/**
 * SpellChecker 통합 테스트 (실제 API 호출)
 * CI 환경에서는 스킵 (외부 API 의존성)
 */
@EnabledIfEnvironmentVariable(named = "INTEGRATION_TEST", matches = "true", disabledReason = "외부 API 의존 테스트")
class SpellCheckerIntegrationTest {
    private lateinit var spellChecker: SpellChecker

    @BeforeEach
    fun setUp() {
        spellChecker = SpellChecker(ObjectMapper())
    }

    @Test
    fun `should correct trailing jamo`() =
        runBlocking {
            val result = spellChecker.correct("생물인가요ㅕ")

            // 끝 자모 제거됨
            assertThat(result).doesNotContain("ㅕ")
            assertThat(result).isEqualTo("생물인가요?")
        }

    @Test
    fun `should correct common typos`() =
        runBlocking {
            val testCases =
                mapOf(
                    "안녕하세요" to "안녕하세요", // 정상 → 그대로
                    "먹엇어요" to "먹었어요",
                    "하겟습니다" to "하겠습니다",
                    "괜찬아요" to "괜찮아요",
                )

            testCases.forEach { (input, expected) ->
                val result = spellChecker.correct(input)
                println("'$input' → '$result' (expected: '$expected')")

                // 부산대 API가 교정했거나, 원본 그대로 유지
                assertThat(result).isIn(expected, input)
            }
        }

    @Test
    fun `should return original for empty or short text`() =
        runBlocking {
            assertThat(spellChecker.correct("")).isEmpty()
            assertThat(spellChecker.correct("a")).isEqualTo("a")
        }

    @Test
    fun `should use cache on second call`() =
        runBlocking {
            val text = "테스트 문장입니다"

            // 첫 번째 호출
            val result1 = spellChecker.correct(text)

            // 두 번째 호출 (캐시 히트)
            val result2 = spellChecker.correct(text)

            assertThat(result1).isEqualTo(result2)

            // 캐시 통계 확인
            val stats = spellChecker.getCacheStats()
            assertThat(stats.hitCount()).isGreaterThan(0)
        }

    @Test
    fun `should handle text longer than max length`() =
        runBlocking {
            val longText = "가".repeat(300)

            val result = spellChecker.correct(longText)

            // 길이 제한 초과시 전처리만 적용
            assertThat(result).isNotNull()
            assertThat(result.length).isLessThanOrEqualTo(longText.length)
        }

    @Test
    fun `should handle network errors gracefully`() =
        runBlocking {
            // 잘못된 URL로 테스트 (실제로는 내부적으로 처리됨)
            val text = "정상적인 텍스트"
            val result = spellChecker.correct(text)

            // 에러 발생 시 원본 또는 전처리된 텍스트 반환
            assertThat(result).isNotNull()
        }

    @Test
    fun `should preprocess trailing jamo before API call`() =
        runBlocking {
            val result = spellChecker.correct("안녕하세요ㅋㅋㅋ")

            // 끝 자모 제거됨
            assertThat(result).doesNotContain("ㅋㅋㅋ")
        }
}
