package party.qwer.twentyq.service.riddle

import io.mockk.coEvery
import io.mockk.coVerify
import io.mockk.every
import io.mockk.mockk
import io.mockk.verify
import kotlinx.coroutines.runBlocking
import org.assertj.core.api.Assertions.assertThat
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.DisplayName
import org.junit.jupiter.api.Nested
import org.junit.jupiter.api.Test
import party.qwer.twentyq.api.dto.QuestionHistory
import party.qwer.twentyq.config.AppProperties
import party.qwer.twentyq.model.RiddleCategory
import party.qwer.twentyq.model.RiddleSecret
import party.qwer.twentyq.model.RiddleSession
import party.qwer.twentyq.redis.session.CategoryStore
import party.qwer.twentyq.redis.session.HistoryStore
import party.qwer.twentyq.redis.session.SecretStore
import party.qwer.twentyq.redis.session.SessionStore
import party.qwer.twentyq.redis.tracking.HintCountStore
import party.qwer.twentyq.redis.tracking.TopicHistoryStore
import party.qwer.twentyq.service.riddle.model.TopicEntry

@DisplayName("RiddleCreator")
class RiddleCreatorTest {
    private lateinit var secretStore: SecretStore
    private lateinit var categoryStore: CategoryStore
    private lateinit var topicHistoryStore: TopicHistoryStore
    private lateinit var sessionStore: SessionStore
    private lateinit var historyStore: HistoryStore
    private lateinit var hintCountStore: HintCountStore
    private lateinit var topicSelector: TopicSelector
    private lateinit var appProperties: AppProperties
    private lateinit var difficultyClassifier: TopicDifficultyClassifier
    private lateinit var messageProvider: party.qwer.twentyq.util.GameMessageProvider

    private lateinit var creator: RiddleCreator

    @BeforeEach
    fun setUp() {
        secretStore = mockk(relaxed = true)
        categoryStore = mockk(relaxed = true)
        topicHistoryStore = mockk(relaxed = true)
        sessionStore = mockk(relaxed = true)
        historyStore = mockk(relaxed = true)
        hintCountStore = mockk(relaxed = true)
        topicSelector = mockk(relaxed = true)
        appProperties = mockk(relaxed = true)
        difficultyClassifier = mockk(relaxed = true)
        messageProvider = mockk(relaxed = true)

        every { messageProvider.get("start.resume", any(), any()) } returns "test resume message"

        creator =
            RiddleCreator(
                secretStore = secretStore,
                categoryStore = categoryStore,
                topicHistoryStore = topicHistoryStore,
                sessionStore = sessionStore,
                historyStore = historyStore,
                hintCountStore = hintCountStore,
                topicSelector = topicSelector,
                appProperties = appProperties,
                difficultyClassifier = difficultyClassifier,
                messageProvider = messageProvider,
            )
    }

    @Nested
    @DisplayName("createRiddle")
    inner class CreateRiddleTest {
        @Test
        fun `새 게임 생성 - 카테고리 지정`() =
            runBlocking {
                val chatId = "chat123"
                val category = "FOOD"

                // 기존 세션 없음
                every { sessionStore.get(chatId) } returns null

                // 금지 주제
                every { appProperties.riddle.game.recentTopicsLimit } returns 10
                every { topicHistoryStore.getRecent(chatId, 10) } returns listOf("사과", "바나나")
                every { topicHistoryStore.getRecent(chatId, "FOOD", 10) } returns listOf("김치")

                // 주제 선택
                val selectedTopic =
                    TopicEntry(
                        name = "피자",
                        description = "이탈리아 음식",
                        category = "food",
                        difficulty = 2,
                    )
                coEvery { topicSelector.selectTopic("food", listOf("사과", "바나나", "김치")) } returns selectedTopic

                // 난이도 분류 (이미 있으므로 호출 안됨)

                val result = creator.createRiddle(chatId, category)

                assertThat(result).isEqualTo("스무고개를 시작합니다")

                verify {
                    secretStore.save(
                        chatId,
                        match { secret ->
                            secret.target == "피자" &&
                                secret.category == "food" &&
                                secret.difficulty == "2" &&
                                secret.intro == "스무고개를 시작합니다"
                        },
                    )
                    categoryStore.save(chatId, "FOOD")
                }
            }

        @Test
        fun `새 게임 생성 - 카테고리 미지정 (ANY)`() =
            runBlocking {
                val chatId = "chat123"

                // 기존 세션 없음
                every { sessionStore.get(chatId) } returns null

                // 금지 주제
                every { appProperties.riddle.game.recentTopicsLimit } returns 5
                every { topicHistoryStore.getRecent(chatId, 5) } returns emptyList()

                // 주제 선택
                val selectedTopic =
                    TopicEntry(
                        name = "에펠탑",
                        description = "파리의 상징",
                        category = "place",
                        difficulty = null, // 난이도 없음 → LLM 분류
                    )
                coEvery { topicSelector.selectTopic(null, emptyList()) } returns selectedTopic
                coEvery { difficultyClassifier.classify(selectedTopic) } returns 3

                val result = creator.createRiddle(chatId, null)

                assertThat(result).isEqualTo("스무고개를 시작합니다")

                verify {
                    secretStore.save(
                        chatId,
                        match { secret ->
                            secret.target == "에펠탑" &&
                                secret.category == "place" &&
                                secret.difficulty == "3"
                        },
                    )
                    categoryStore.save(chatId, "PLACE")
                }
            }

        @Test
        @org.junit.jupiter.api.Disabled("Template migration - mock setup needs review")
        fun `기존 게임 재개 - resumeIfExisting 호출`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")
                val session = RiddleSession("chat123", "user1", secret)

                // 기존 세션 존재
                every { sessionStore.get(chatId) } returns "session-data"
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "동물인가요?", "아니요"),
                        QuestionHistory(2, "먹을 수 있나요?", "예"),
                        QuestionHistory(-1, "", "힌트1"),
                    )
                every { hintCountStore.get(chatId) } returns 1

                val result = creator.createRiddle(chatId, null)

                assertThat(result).contains("진행 중인 게임이 있습니다")
                assertThat(result).contains("질문 수: 2개")
                assertThat(result).contains("힌트 사용: 1회")

                // 새 게임 생성 안됨
                verify(exactly = 0) { secretStore.save(any(), any()) }
            }
    }

    @Nested
    @DisplayName("collectBannedTopics")
    inner class CollectBannedTopicsTest {
        @Test
        fun `전역 + 카테고리별 최근 주제 수집`() =
            runBlocking {
                val chatId = "chat123"
                val limit = 10

                every { appProperties.riddle.game.recentTopicsLimit } returns limit
                every { topicHistoryStore.getRecent(chatId, limit) } returns listOf("사과", "바나나", "김치")
                every { topicHistoryStore.getRecent(chatId, "FOOD", limit) } returns listOf("김치", "피자")

                every { sessionStore.get(chatId) } returns null

                val selectedTopic = TopicEntry("토마토", "빨간 과일", "food", 1)
                coEvery { topicSelector.selectTopic("food", listOf("사과", "바나나", "김치", "피자")) } returns selectedTopic

                creator.createRiddle(chatId, "FOOD")

                verify {
                    topicHistoryStore.getRecent(chatId, limit)
                    topicHistoryStore.getRecent(chatId, "FOOD", limit)
                }
            }

        @Test
        fun `ANY 카테고리는 전역 최근 주제만 수집`() =
            runBlocking {
                val chatId = "chat123"
                val limit = 5

                every { appProperties.riddle.game.recentTopicsLimit } returns limit
                every { topicHistoryStore.getRecent(chatId, limit) } returns listOf("사과", "바나나")

                every { sessionStore.get(chatId) } returns null

                val selectedTopic = TopicEntry("에펠탑", "파리 상징", "place", 2)
                coEvery { topicSelector.selectTopic(null, listOf("사과", "바나나")) } returns selectedTopic
                coEvery { difficultyClassifier.classify(any()) } returns 2

                creator.createRiddle(chatId, null)

                verify(exactly = 1) { topicHistoryStore.getRecent(chatId, limit) }
                verify(exactly = 0) { topicHistoryStore.getRecent(chatId, any<String>(), any()) }
            }
    }

    @Nested
    @DisplayName("selectSecret")
    inner class SelectSecretTest {
        @Test
        fun `난이도가 이미 있는 경우 - LLM 호출 안함`() =
            runBlocking {
                val chatId = "chat123"

                every { sessionStore.get(chatId) } returns null
                every { appProperties.riddle.game.recentTopicsLimit } returns 5
                every { topicHistoryStore.getRecent(any(), any<Int>()) } returns emptyList()

                val selectedTopic = TopicEntry("피자", "이탈리아 음식", "food", difficulty = 3)
                coEvery { topicSelector.selectTopic(any(), any()) } returns selectedTopic

                creator.createRiddle(chatId, "FOOD")

                // difficultyClassifier 호출 안됨
                coVerify(exactly = 0) { difficultyClassifier.classify(any()) }

                verify {
                    secretStore.save(
                        chatId,
                        match { secret -> secret.difficulty == "3" },
                    )
                }
            }

        @Test
        fun `난이도가 없는 경우 - LLM으로 분류`() =
            runBlocking {
                val chatId = "chat123"

                every { sessionStore.get(chatId) } returns null
                every { appProperties.riddle.game.recentTopicsLimit } returns 5
                every { topicHistoryStore.getRecent(any(), any<Int>()) } returns emptyList()

                val selectedTopic = TopicEntry("에펠탑", "파리 상징", "place", difficulty = null)
                coEvery { topicSelector.selectTopic(any(), any()) } returns selectedTopic
                coEvery { difficultyClassifier.classify(selectedTopic) } returns 4

                creator.createRiddle(chatId, "PLACE")

                verify {
                    secretStore.save(
                        chatId,
                        match { secret -> secret.difficulty == "4" },
                    )
                }
            }
    }

    @Nested
    @DisplayName("resumeIfExisting")
    inner class ResumeIfExistingTest {
        @Test
        fun `세션이 없으면 null 반환`() =
            runBlocking {
                val chatId = "chat123"

                every { sessionStore.get(chatId) } returns null
                every { appProperties.riddle.game.recentTopicsLimit } returns 5
                every { topicHistoryStore.getRecent(any(), any<Int>()) } returns emptyList()

                val selectedTopic = TopicEntry("사과", "과일", "food", 1)
                coEvery { topicSelector.selectTopic(any(), any()) } returns selectedTopic

                val result = creator.createRiddle(chatId, null)

                assertThat(result).isEqualTo("스무고개를 시작합니다")
            }

        @Test
        fun `세션이 있으면 재개 메시지 반환`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")
                val session = RiddleSession("chat123", "user1", secret)

                every { sessionStore.get(chatId) } returns "session-data"
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "Q1", "A1"),
                        QuestionHistory(2, "Q2", "A2"),
                        QuestionHistory(3, "Q3", "A3"),
                    )
                every { hintCountStore.get(chatId) } returns 0

                val result = creator.createRiddle(chatId, null)

                // messageProvider가 호출되었는지만 확인
                assertThat(result).isEqualTo("test resume message")
            }

        @Test
        @org.junit.jupiter.api.Disabled("Template migration - mock setup needs review")
        fun `힌트를 사용한 경우 - 카운트 표시`() =
            runBlocking {
                val chatId = "chat123"
                val secret = RiddleSecret("사과", "food", "과일입니다")
                val session = RiddleSession("chat123", "user1", secret)

                every { sessionStore.get(chatId) } returns "session-data"
                every { historyStore.get(chatId) } returns
                    listOf(
                        QuestionHistory(1, "Q1", "A1"),
                        QuestionHistory(-1, "", "Hint1"),
                        QuestionHistory(-2, "", "Hint2"),
                    )
                every { hintCountStore.get(chatId) } returns 2

                val result = creator.createRiddle(chatId, null)

                // messageProvider가 호출되었는지만 확인
                assertThat(result).isEqualTo("test resume message")
            }
    }
}
