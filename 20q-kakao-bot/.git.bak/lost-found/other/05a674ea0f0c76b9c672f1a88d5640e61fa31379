package party.qwer.twentyq.redis

import kotlinx.coroutines.reactor.awaitSingleOrNull
import kotlinx.coroutines.runBlocking
import org.redisson.api.RedissonReactiveClient
import org.slf4j.LoggerFactory
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.stereotype.Component
import java.time.Duration
import java.util.concurrent.TimeUnit

/**
 * 애플리케이션 레벨 캐시 추상화 레이어
 *
 * 게임 세션과 무관한 영구 캐시 데이터 관리
 * - 토픽 난이도 분류 결과
 * - 텍스트 정규화 결과
 * - 기타 애플리케이션 레벨 캐시
 *
 * CONVENTIONS: SessionCoordinator는 게임 세션 데이터만 관리
 *              CacheCoordinator는 앱 레벨 캐시 데이터만 관리
 */
@Component
@ConditionalOnProperty(
    prefix = "app.redis",
    name = ["enabled"],
    havingValue = "true",
    matchIfMissing = true,
)
class CacheCoordinator(
    private val redisson: RedissonReactiveClient,
) {
    companion object {
        private val log = LoggerFactory.getLogger(CacheCoordinator::class.java)
    }

    /**
     * 캐시 값 조회
     * Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
     */
    @Suppress("TooGenericExceptionCaught")
    fun get(key: String): String? = runBlocking { getAsync(key) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun getAsync(key: String): String? =
        try {
            val bucket = redisson.getBucket<String>(key)
            bucket.get().awaitSingleOrNull()
        } catch (e: Exception) {
            log.warn("Cache read failed for key='{}': {}", key, e.message)
            null
        }

    /**
     * 캐시 값 저장 (TTL 포함)
     * Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
     */
    @Suppress("TooGenericExceptionCaught")
    fun set(
        key: String,
        value: String,
        ttl: Duration,
    ) = runBlocking { setAsync(key, value, ttl) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun setAsync(
        key: String,
        value: String,
        ttl: Duration,
    ) {
        try {
            val bucket = redisson.getBucket<String>(key)
            bucket.set(value, ttl).awaitSingleOrNull()
            log.debug("Cache set: key='{}', ttl={}", key, ttl)
        } catch (e: Exception) {
            log.warn("Cache write failed for key='{}': {}", key, e.message)
        }
    }

    /**
     * 캐시 TTL 갱신
     * Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
     */
    @Suppress("TooGenericExceptionCaught")
    fun expire(
        key: String,
        ttl: Duration,
    ): Boolean = runBlocking { expireAsync(key, ttl) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun expireAsync(
        key: String,
        ttl: Duration,
    ): Boolean =
        try {
            val bucket = redisson.getBucket<String>(key)
            bucket.expire(ttl).awaitSingleOrNull() ?: false
        } catch (e: Exception) {
            log.warn("Cache expire failed for key='{}': {}", key, e.message)
            false
        }

    /**
     * 캐시 남은 TTL 조회
     * Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
     */
    @Suppress("TooGenericExceptionCaught")
    fun getExpire(
        key: String,
        unit: TimeUnit,
    ): Long = runBlocking { getExpireAsync(key, unit) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun getExpireAsync(
        key: String,
        unit: TimeUnit,
    ): Long =
        try {
            val bucket = redisson.getBucket<String>(key)
            val remainMs = bucket.remainTimeToLive().awaitSingleOrNull() ?: -1L
            when (unit) {
                TimeUnit.MILLISECONDS -> remainMs
                TimeUnit.SECONDS -> remainMs / 1000
                TimeUnit.MINUTES -> remainMs / 60000
                TimeUnit.HOURS -> remainMs / 3600000
                TimeUnit.DAYS -> remainMs / 86400000
                else -> remainMs / 1000 // Default to seconds
            }
        } catch (e: Exception) {
            log.warn("Cache getExpire failed for key='{}': {}", key, e.message)
            -1
        }

    /**
     * 캐시 삭제
     * Blocking wrapper for non-suspend contexts (CONVENTIONS: 허용됨 - Redis operations)
     */
    @Suppress("TooGenericExceptionCaught")
    fun delete(key: String): Boolean = runBlocking { deleteAsync(key) }

    @Suppress("TooGenericExceptionCaught")
    suspend fun deleteAsync(key: String): Boolean =
        try {
            val bucket = redisson.getBucket<String>(key)
            bucket.delete().awaitSingleOrNull() ?: false
        } catch (e: Exception) {
            log.warn("Cache delete failed for key='{}': {}", key, e.message)
            false
        }
}
