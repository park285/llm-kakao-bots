package party.qwer.twentyq.security

import com.github.benmanes.caffeine.cache.Cache
import com.github.benmanes.caffeine.cache.Caffeine
import com.google.re2j.Pattern
import com.ibm.icu.text.Normalizer2
import kotlinx.coroutines.runBlocking
import org.ahocorasick.trie.Emit
import org.ahocorasick.trie.Trie
import org.slf4j.LoggerFactory
import org.springframework.stereotype.Component
import party.qwer.twentyq.config.AppProperties
import java.util.Locale
import java.util.concurrent.TimeUnit

@Component
class RiddleInjectionGuard(
    private val appProperties: AppProperties,
    private val kiwiService: party.qwer.twentyq.service.KomoranService,
) {
    companion object {
        private val log = LoggerFactory.getLogger(RiddleInjectionGuard::class.java)
        private val JAMO_BLOCK_REGEX = Regex("[\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]")
        private val JAMO_ONLY_REGEX = Regex("^[\\p{Z}\\p{P}\\p{N}\\u1100-\\u11FF\\u3130-\\u318F\\uA960-\\uA97F\\uD7B0-\\uD7FF]+$")
    }

    private val loader = RiddleGuardRulepackLoader()
    private val compiled = mutableListOf<CompiledPack>()
    private val globalThreshold: Double
    private val evaluationCache: Cache<String, Evaluation>

    init {
        val cfg = appProperties.security.injection
        globalThreshold = cfg.threshold
        val packs = loader.loadFromResources(cfg.rulepacks)
        packs.forEach { compiled += compile(it) }

        evaluationCache =
            Caffeine
                .newBuilder()
                .maximumSize(10_000)
                .expireAfterWrite(1, TimeUnit.HOURS)
                .recordStats()
                .build()

        log.info("InjectionGuard initialized: packs={}, threshold={}, cache enabled", compiled.size, globalThreshold)
    }

    data class CompiledPack(
        val threshold: Double,
        val regexes: List<Triple<String, Pattern, Double>>,
        val trie: Trie,
        val phraseWeights: Map<String, Double>,
    )

    private fun compile(pack: Rulepack): CompiledPack {
        val regexes =
            buildList {
                pack.rules.forEach { r ->
                    if (r is Rule.RegexRule) {
                        add(Triple(r.id, Pattern.compile(r.pattern), r.weight))
                    }
                }
            }

        val phrases =
            buildList {
                pack.rules.forEach { r ->
                    if (r is Rule.PhrasesRule) {
                        r.phrases.forEach { p ->
                            add(p.lowercase(Locale.KOREAN))
                        }
                    }
                }
            }

        val phraseWeights =
            buildMap {
                pack.rules.forEach { r ->
                    if (r is Rule.PhrasesRule) {
                        r.phrases.forEach { p ->
                            put(p.lowercase(Locale.KOREAN), r.weight)
                        }
                    }
                }
            }
        val trie =
            Trie
                .builder()
                .onlyWholeWords()
                .ignoreCase()
                .addKeywords(phrases)
                .build()
        return CompiledPack(
            threshold = pack.threshold,
            regexes = regexes,
            trie = trie,
            phraseWeights = phraseWeights,
        )
    }

    data class Evaluation(
        val score: Double,
        val matches: List<GuardMatch>,
        val threshold: Double,
    ) {
        val malicious: Boolean get() = score >= threshold
    }

    fun evaluate(input: String): Evaluation {
        if (!appProperties.security.injection.enabled) {
            return Evaluation(0.0, emptyList(), Double.POSITIVE_INFINITY)
        }

        return evaluationCache.get(input) { key -> evaluateInternal(key) }
    }

    private fun evaluateInternal(input: String): Evaluation {
        val threshold = if (globalThreshold > 0) globalThreshold else compiled.maxOfOrNull { it.threshold } ?: 0.7
        if (isJamoOnly(input)) {
            log.warn("InjectionGuard JAMO_ONLY_BLOCK text='{}'", input.take(80))
            return Evaluation(threshold, listOf(GuardMatch("jamo_only", threshold)), threshold)
        }

        // 이모지 차단 (스무고개에 이모지는 불필요하며 인젝션 공격 가능성 높음)
        if (containsEmoji(input)) {
            log.warn("InjectionGuard EMOJI_BLOCK text='{}'", input.take(80))
            return Evaluation(threshold, listOf(GuardMatch("emoji_detected", threshold)), threshold)
        }

        val text = normalize(input)
        var total = 0.0
        val hits = mutableListOf<GuardMatch>()
        compiled.forEach { pack ->
            pack.regexes.forEach { (id, pat, w) ->
                if (pat.matcher(text).find()) {
                    total += w
                    hits += GuardMatch(id, w)
                }
            }
            val emits: MutableCollection<Emit> = pack.trie.parseText(text)
            emits.forEach { emit ->
                val key = emit.keyword.lowercase(Locale.KOREAN)
                val w = pack.phraseWeights[key] ?: 0.0
                if (w > 0.0) {
                    total += w
                    hits += GuardMatch("phrase:$key", w)
                }
            }
        }
        try {
            val anomalyScore = runBlocking { kiwiService.calculateAnomalyScore(input) }
            if (anomalyScore > 0.5) {
                total += anomalyScore
                hits += GuardMatch("kiwi_anomaly", anomalyScore)
                log.debug(
                    "InjectionGuard KIWI_ANOMALY text='{}', score={}",
                    input.take(50),
                    anomalyScore,
                )
            }
        } catch (e: Exception) {
            log.warn("Kiwi anomaly detection failed: {}", e.message)
        }

        return Evaluation(total, hits, threshold)
    }

    fun isMalicious(input: String): Boolean = evaluate(input).malicious

    private fun normalize(s: String): String {
        val nfkc = Normalizer2.getNFKCInstance().normalize(s)
        val sb = StringBuilder(nfkc.length)
        nfkc.forEach { ch ->
            val t = Character.getType(ch)
            if (t != Character.FORMAT.toInt() && t != Character.CONTROL.toInt()) {
                sb.append(ch)
            }
        }
        return sb.toString()
    }

    private fun isJamoOnly(s: String): Boolean {
        val t = s.trim()
        if (t.isEmpty()) return false
        return JAMO_BLOCK_REGEX.containsMatchIn(t) && JAMO_ONLY_REGEX.matches(t)
    }

    // 이모지 감지 (Unicode codePoint 기반)
    private fun containsEmoji(text: String): Boolean {
        val codePoints = text.codePoints().toArray()
        for (cp in codePoints) {
            if (cp in 0x1F300..0x1FAFF || // Emoji blocks
                cp in 0x2600..0x27BF || // Miscellaneous Symbols
                cp in 0x1F900..0x1F9FF || // Supplemental Symbols
                cp in 0x1F600..0x1F64F || // Emoticons
                cp in 0x1F680..0x1F6FF || // Transport
                cp == 0x200D || // ZWJ
                cp in 0xFE00..0xFE0F || // Variation Selectors
                cp in 0x1F3FB..0x1F3FF || // Skin tones
                cp in 0x2300..0x23FF || // Miscellaneous Technical
                cp in 0x2B50..0x2B55 // Stars
            ) {
                return true
            }
        }
        return false
    }
}
